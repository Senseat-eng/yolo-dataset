<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ğŸ¥‘ YOLO Dataset Creator - Manual Polygon</title>
<script src="https://unpkg.com/@supabase/supabase-js@2.38.0/dist/umd/supabase.js"></script>
<script type="module">
    try {
        const { client } = await import("https://cdn.jsdelivr.net/npm/@gradio/client/+esm");
        window.gradioClient = client;
        window.gradioClientLoaded = true;
        console.log('âœ… Gradio Client loaded successfully');
    } catch (error) {
        console.error('âŒ Failed to load Gradio Client:', error);
        window.gradioClientLoaded = false;
        window.gradioClientError = error.message;
    }
</script>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }

body {
font-family: Arial, sans-serif;
background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
min-height: 100vh;
color: white;
padding: 20px;
}

.container { max-width: 900px; margin: 0 auto; }

.header {
text-align: center;
background: rgba(255,255,255,0.1);
padding: 30px;
border-radius: 20px;
margin-bottom: 30px;
}

h1 { font-size: 2em; margin-bottom: 10px; }

.login-section {
background: rgba(255,255,255,0.15);
padding: 25px;
border-radius: 15px;
text-align: center;
margin: 20px 0;
}

.user-input {
padding: 12px 20px;
border: none;
border-radius: 25px;
font-size: 16px;
margin: 10px;
min-width: 200px;
text-align: center;
background: rgba(255,255,255,0.9);
color: #333;
}

.btn {
padding: 12px 25px;
border: none;
border-radius: 25px;
cursor: pointer;
font-weight: bold;
font-size: 16px;
color: white;
margin: 10px;
background: linear-gradient(45deg, #667eea, #764ba2);
transition: transform 0.2s;
}

.btn:hover { transform: translateY(-2px); }

.main-content { display: none; }

.upload-zone {
border: 2px dashed rgba(255,255,255,0.5);
border-radius: 15px;
padding: 40px 20px;
text-align: center;
margin: 20px 0;
cursor: pointer;
transition: all 0.3s;
}

.upload-zone:hover {
border-color: rgba(255,255,255,0.8);
background: rgba(255,255,255,0.05);
}

.categories {
display: grid;
grid-template-columns: repeat(3, 1fr);
gap: 10px;
margin: 20px 0;
}

.category-btn {
padding: 10px 8px;
border: none;
border-radius: 10px;
cursor: pointer;
font-weight: bold;
font-size: 14px;
background: rgba(255,255,255,0.2);
color: white;
border: 2px solid transparent;
transition: all 0.3s;
}

.category-btn:hover {
background: rgba(255,255,255,0.3);
transform: translateY(-2px);
}

.category-btn.selected {
background: linear-gradient(45deg, #ff9a9e, #fecfef);
border-color: white;
box-shadow: 0 4px 15px rgba(255,255,255,0.3);
}

.canvas-container {
text-align: center;
margin: 20px auto;
position: relative;
overflow: visible;
border-radius: 15px;
background: #2a2a2a;
display: block;
max-width: fit-content;
margin-left: auto;
margin-right: auto;
}

.canvas-wrapper {
position: relative;
display: inline-block;
transform-origin: center center;
transition: transform 0.2s ease-out;
}

#imageCanvas {
border-radius: 15px;
max-width: 100%;
max-height: 60vh;
cursor: crosshair;
box-shadow: 0 8px 32px rgba(0,0,0,0.3);
display: block;
}

/* Polygon drawing mode */
#imageCanvas.polygon-mode {
cursor: cell;
}

/* Polygon Action Buttons - positioned directly touching below rectangle */
.polygon-controls {
position: absolute;
display: none;
gap: 8px;
z-index: 20;
background: rgba(0,0,0,0.8);
padding: 8px 12px;
border-radius: 50px;
box-shadow: 0 4px 20px rgba(0,0,0,0.6);
left: 50%;
transform: translateX(-50%);
}

.polygon-controls.active {
display: flex;
}

.polygon-btn {
width: 36px;
height: 36px;
border-radius: 50%;
border: 2px solid white;
font-size: 17px;
box-shadow: 0 4px 12px rgba(0,0,0,0.5);
cursor: pointer;
transition: all 0.2s;
display: flex;
align-items: center;
justify-content: center;
}

.polygon-btn:hover {
transform: scale(1.1);
box-shadow: 0 6px 16px rgba(0,0,0,0.6);
}

.polygon-btn.accept {
background: linear-gradient(45deg, #4CAF50, #45a049);
color: white;
width: 43px;
height: 43px;
font-size: 20px;
}

.polygon-btn.retry {
background: linear-gradient(45deg, #ff9800, #f57c00);
color: white;
}

.polygon-btn.undo {
background: linear-gradient(45deg, #2196F3, #1976D2);
color: white;
}

/* Zoom controls */
.zoom-controls {
position: absolute;
top: 10px;
left: 10px;
display: none;
flex-direction: column;
gap: 5px;
z-index: 10;
}

.zoom-controls.active {
display: flex;
}

.zoom-btn {
width: 40px;
height: 40px;
border-radius: 50%;
border: none;
background: rgba(255,255,255,0.9);
font-size: 20px;
cursor: pointer;
box-shadow: 0 2px 8px rgba(0,0,0,0.2);
transition: all 0.2s;
}

.zoom-btn:hover {
transform: scale(1.1);
background: white;
}

/* Clear button - positioned next to image */
.clear-btn {
position: absolute;
top: 10px;
right: 10px;
width: 50px;
height: 50px;
border-radius: 50%;
border: none;
background: linear-gradient(45deg, #ff416c, #ff4b2b);
color: white;
font-size: 24px;
cursor: pointer;
box-shadow: 0 4px 12px rgba(0,0,0,0.3);
z-index: 10;
transition: all 0.2s;
}

.clear-btn:hover {
transform: scale(1.1);
box-shadow: 0 6px 16px rgba(0,0,0,0.4);
}

/* Polygon info overlay */
.polygon-info {
position: absolute;
top: 10px;
right: 10px;
background: rgba(0,0,0,0.7);
color: white;
padding: 10px 15px;
border-radius: 8px;
font-size: 14px;
display: none;
z-index: 10;
}

.polygon-info.active {
display: block;
}

/* ========== ORIGINAL PARAMETERS SECTION (NOW UNUSED) ========== */
/* REVERSIBLE: Original styling - restore this if reverting */
.parameters-section {
background: rgba(255,255,255,0.1);
border-radius: 15px;
padding: 20px;
margin: 20px 0;
}
/* When parameters are in left panel, hide the original section */
.parameters-section.in-left-panel {
display: none;
}

.param-group {
margin-bottom: 20px;
}

.param-group-header {
font-size: 1.2em;
font-weight: bold;
margin-bottom: 15px;
padding: 10px;
background: rgba(255,255,255,0.15);
border-radius: 10px;
cursor: pointer;
user-select: none;
display: flex;
justify-content: space-between;
align-items: center;
}

.param-group-header:hover {
background: rgba(255,255,255,0.2);
}

.toggle-icon {
font-size: 1.5em;
transition: transform 0.3s;
}

.toggle-icon.collapsed {
transform: rotate(-90deg);
}

.param-group-content {
max-height: 1000px;
overflow: hidden;
transition: max-height 0.3s ease;
}

.param-group-content.collapsed {
max-height: 0;
}

.param-item {
background: rgba(255,255,255,0.08);
padding: 15px;
border-radius: 10px;
margin-bottom: 12px;
}

.param-label {
display: flex;
justify-content: space-between;
margin-bottom: 8px;
font-weight: bold;
}

.param-value {
color: #ffd700;
font-size: 1.1em;
}

.slider-container {
position: relative;
padding: 0 10px;
}

.slider-labels {
display: flex;
justify-content: space-between;
font-size: 0.75em;
color: rgba(255,255,255,0.7);
margin-top: 4px;
}

.slider {
width: 100%;
height: 8px;
border-radius: 5px;
outline: none;
-webkit-appearance: none;
}

.slider.linear {
background: linear-gradient(to right, #ff4444, #ffaa00, #44ff44);
}

.slider.optimal {
background: linear-gradient(to right, #ff4444, #ffaa00 25%, #44ff44 50%, #ffaa00 75%, #ff4444);
}

.slider.reversed {
background: linear-gradient(to right, #44ff44, #ffaa00, #ff4444);
}

.slider::-webkit-slider-thumb {
-webkit-appearance: none;
appearance: none;
width: 20px;
height: 20px;
border-radius: 50%;
background: linear-gradient(45deg, #ffd700, #ffed4e);
cursor: pointer;
box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

.slider::-moz-range-thumb {
width: 20px;
height: 20px;
border-radius: 50%;
background: linear-gradient(45deg, #ffd700, #ffed4e);
cursor: pointer;
border: none;
box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

/* ========== LAYOUT CHANGE: LEFT PANEL FOR SLIDERS ========== */
/* LEFT side parameters panel - REVERSIBLE CHANGE START */
.left-panel {
position: absolute;
left: -220px;
top: 0;
width: 210px;
max-height: 600px;
overflow-y: auto;
overflow-x: hidden;
display: flex;
flex-direction: column;
gap: 5px;
background: rgba(255,255,255,0.05);
border-radius: 10px;
padding: 10px;
}

.left-panel h3 {
font-size: 14px;
margin: 5px 0 10px 0;
text-align: center;
}

/* Compact slider styling for left panel */
.left-panel .param-group {
margin-bottom: 10px;
}

.left-panel .param-group-header {
padding: 8px 10px;
font-size: 13px;
}

.left-panel .param-item {
margin-bottom: 8px;
}

.left-panel .param-label {
font-size: 12px;
margin-bottom: 3px;
}

.left-panel .slider-container {
display: flex;
align-items: center;
gap: 8px;
}

.left-panel input[type="range"] {
flex: 1;
height: 6px;
}

.left-panel .param-value {
min-width: 35px;
font-size: 12px;
padding: 3px 6px;
}

/* Mobile responsiveness - move panel below canvas on small screens */
@media (max-width: 1100px) {
.left-panel {
position: relative;
left: 0;
width: 100%;
max-height: none;
margin-bottom: 20px;
}
}
/* REVERSIBLE CHANGE END */

/* Annotation list */
.annotation-list {
background: rgba(255,255,255,0.1);
border-radius: 15px;
padding: 15px;
margin: 20px 0;
max-height: 300px;
overflow-y: auto;
}

.annotation-list h3 {
text-align: center;
margin-bottom: 15px;
font-size: 1.1em;
}

.annotation-item {
background: rgba(255,255,255,0.15);
border-radius: 10px;
padding: 12px;
margin-bottom: 10px;
cursor: pointer;
transition: all 0.2s;
border: 2px solid transparent;
display: flex;
justify-content: space-between;
align-items: center;
}

.annotation-item:hover {
background: rgba(255,255,255,0.25);
transform: translateX(-3px);
}

.annotation-item.selected {
border-color: #4CAF50;
background: rgba(76, 175, 80, 0.2);
}

.annotation-item-info {
flex: 1;
}

.annotation-item-title {
font-weight: bold;
margin-bottom: 5px;
}

.annotation-item-score {
font-size: 0.9em;
color: #ffd700;
}

.annotation-item-actions {
display: flex;
gap: 5px;
}

.annotation-item-btn {
padding: 5px 10px;
border: none;
border-radius: 5px;
cursor: pointer;
font-size: 0.85em;
background: rgba(255,255,255,0.2);
color: white;
transition: all 0.2s;
}

.annotation-item-btn:hover {
background: rgba(255,255,255,0.4);
transform: scale(1.05);
}

.annotation-item-btn.edit {
background: linear-gradient(45deg, #2196F3, #1976D2);
}

.annotation-item-btn.delete {
background: linear-gradient(45deg, #ff416c, #ff4b2b);
}

/* Right side control panel - ONLY PREVIEW NOW */
.control-panel {
position: absolute;
right: -190px;
top: 0;
width: 180px;
display: flex;
flex-direction: column;
gap: 10px;
}

/* Mobile responsiveness - move panel below canvas on small screens */
@media (max-width: 900px) {
.control-panel {
position: relative;
right: 0;
width: 100%;
margin-top: 20px;
}
}

/* Preview canvas */
.preview-container {
margin-top: 15px;
padding: 10px;
background: rgba(255,255,255,0.1);
border-radius: 10px;
text-align: center;
}

.preview-label {
font-size: 12px;
color: rgba(255,255,255,0.8);
margin-bottom: 5px;
}

#previewCanvas {
width: 100%;
max-width: 150px;
border-radius: 8px;
border: 2px solid rgba(255,255,255,0.3);
display: none;
}

#previewCanvas.active {
display: block;
}

.controls {
display: flex;
justify-content: center;
gap: 10px;
flex-wrap: wrap;
margin: 20px 0;
}

.btn-success { background: linear-gradient(45deg, #56ab2f, #a8e6cf); }
.btn-danger { background: linear-gradient(45deg, #ff416c, #ff4b2b); }
.btn-primary { background: linear-gradient(45deg, #667eea, #764ba2); }

.hidden { display: none !important; }

.notification {
position: fixed;
top: 20px;
right: 20px;
padding: 15px 25px;
border-radius: 10px;
color: white;
font-weight: bold;
z-index: 1000;
transform: translateX(400px);
transition: all 0.3s ease;
max-width: 300px;
box-shadow: 0 4px 15px rgba(0,0,0,0.3);
}

.notification.show { transform: translateX(0); }
.notification.success { background: linear-gradient(45deg, #56ab2f, #a8e6cf); }
.notification.error { background: linear-gradient(45deg, #ff416c, #ff4b2b); }

.status-bar {
padding: 15px;
border-radius: 10px;
margin: 20px 0;
text-align: center;
font-weight: bold;
}

.status-bar.connected { background: rgba(76, 175, 80, 0.3); }
.status-bar.offline { background: rgba(244, 67, 54, 0.3); }

.instructions {
background: rgba(255,255,255,0.1);
padding: 15px;
border-radius: 10px;
margin: 15px 0;
text-align: center;
}

.loading {
text-align: center;
padding: 20px;
font-size: 1.2em;
}
</style>
</head>
<body>
<div class="container">
<div class="header" style="padding: 13px 0;">
<h1 style="font-size: 1.275em; margin-bottom: 7px;">ğŸ“¦ YOLO Dataset Annotation Tool</h1>
</div>

<div style="text-align: center; margin-bottom: 15px;">
<div style="display: inline-block; padding: 8px 16px; background: rgba(255,255,255,0.05); border-radius: 8px; font-size: 13px;">
<span style="color: #4CAF50; font-weight: bold;">âœ“ ××—×•×‘×¨</span>
<span style="margin: 0 8px; color: rgba(255,255,255,0.3);">|</span>
<span>×©×œ×•× <strong id="currentUserTop"></strong></span>
</div>
</div>

<div id="loginSection" class="login-section">
<h2>ğŸš€ ×‘×•× × ×ª×—×™×œ!</h2>
<p><strong>×”×›× ×¡ ××ª ×”×©× ×©×œ×š ×‘×× ×’×œ×™×ª ×‘×œ×‘×“</strong></p>
<p style="font-size: 0.9em; color: #ffeb3b; margin: 10px 0;">âš ï¸ ×¨×§ ××•×ª×™×•×ª ×× ×’×œ×™×•×ª! ×“×•×’××”: Uri, Dan, Maya, Alex</p>
<input type="text" id="userName" class="user-input" placeholder="Your name in English only" maxlength="15">
<br>
<button onclick="login()" class="btn">×”×ª×—×œ ×œ×ª×¨×•×</button>
</div>

<div id="mainApp" class="main-content">

<input type="file" id="imageInput" accept="image/*" style="display:none">
<input type="file" id="cameraInput" accept="image/*" capture="environment" style="display:none">

<div style="display: flex; gap: 10px; justify-content: center; margin: 10px 0;">
<button onclick="document.getElementById('imageInput').click()" class="btn btn-primary">
ğŸ“ ×‘×—×¨ ×§×•×‘×¥
</button>
<button onclick="document.getElementById('cameraInput').click()" class="btn btn-success">
ğŸ“· ×¦×œ× ×ª××•× ×”
</button>
</div>

<div id="categorySection" class="hidden">
<h3>×‘×—×¨ ××ª ×¡×•×’ ×”××•×¦×¨:</h3>
<div class="categories">
<button class="category-btn" data-category="0" data-product="avocado">ğŸ¥‘ ××‘×•×§×“×•</button>
<button class="category-btn" data-category="1" data-product="mango">ğŸ¥­ ×× ×’×•</button>
<button class="category-btn" data-category="2" data-product="cucumber">ğŸ¥’ ××œ×¤×¤×•×Ÿ</button>
<button class="category-btn" data-category="3" data-product="apple">ğŸ ×ª×¤×•×—</button>
<button class="category-btn" data-category="4" data-product="tomato">ğŸ… ×¢×’×‘× ×™×”</button>
<button class="category-btn" data-category="5" data-product="chicken">ğŸ— ×—×–×” ×¢×•×£</button>
</div>
</div>

<div id="canvasSection" class="hidden">
<div class="canvas-container">

<div class="zoom-controls" id="zoomControls">
<button class="zoom-btn" onclick="zoomIn()">+</button>
<button class="zoom-btn" onclick="zoomOut()">âˆ’</button>
<button class="zoom-btn" onclick="resetZoom()">âŒ‚</button>
</div>
<div class="polygon-info" id="polygonInfo">
<div>Points: <span id="pointCount">0</span></div>
<div>Click to add â€¢ Double-click to close</div>
</div>
<div class="polygon-controls" id="polygonControls">
<button class="polygon-btn undo" onclick="undoLastPoint()" title="Undo">â†¶</button>
<button class="polygon-btn retry" onclick="retryPolygon()" title="Retry">ğŸ”„</button>
<button class="polygon-btn accept" onclick="acceptPolygon()" title="Accept">âœ“</button>
</div>
<button class="clear-btn" onclick="clearCanvas()" title="× ×§×” ×”×›×œ">ğŸ—‘ï¸</button>
<div class="canvas-wrapper" id="canvasWrapper">
<canvas id="imageCanvas"></canvas>
</div>

<!-- Right side control panel - ONLY PREVIEW -->
<div class="control-panel">
<!-- Preview of masked crop -->
<div class="preview-container">
<div class="preview-label">×ª×¦×•×’×” ××§×“×™××”:</div>
<canvas id="previewCanvas" width="150" height="150"></canvas>
</div>
</div>

</div>

<div class="instructions">
<strong>×”×•×¨××•×ª:</strong> ×‘×—×¨ ×§×˜×’×•×¨×™×” ×•××– ×œ×—×¥ ×•×’×¨×•×¨ ×¢×œ ×”×ª××•× ×” ×œ×™×¦×™×¨×ª ×¨×™×‘×•×¢ ×¡×‘×™×‘ ×”××•×¦×¨
</div>

<div id="parametersSection" class="parameters-section hidden">
<div id="loadingParams" class="loading">×˜×•×¢×Ÿ ×¤×¨××˜×¨×™×...</div>

<div id="paramsContent" class="hidden">
<h3 style="text-align: center; margin-bottom: 20px;">âš™ï¸ ×”×’×“×¨ ×¤×¨××˜×¨×™× ×œ××•×¦×¨</h3>

<div class="param-group">
<div class="param-group-header" onclick="toggleGroup('visible')">
<span>ğŸ‘ï¸ ×¤×¨××˜×¨×™× × ×¨××™× ×œ××©×ª××©</span>
<span class="toggle-icon" id="toggle-visible">â–¼</span>
</div>
<div class="param-group-content" id="visibleParams"></div>
</div>

<div class="param-group">
<div class="param-group-header" onclick="toggleGroup('hidden')">
<span>ğŸ”’ ×¤×¨××˜×¨×™× × ×¡×ª×¨×™×/×¨×¦×•×™×™×</span>
<span class="toggle-icon" id="toggle-hidden">â–¼</span>
</div>
<div class="param-group-content" id="hiddenParams"></div>
</div>

<!-- Action buttons moved below sliders -->
<div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px; flex-wrap: wrap;">
<button onclick="addCurrentAnnotation()" class="btn btn-warning" id="addAnnotationBtn" style="display:none;">
â• ×”×•×¡×£ (<span id="annotationCount">0</span>)
</button>
<button onclick="deleteLastBox()" class="btn btn-danger" id="deleteBtn" style="display:none;">
ğŸ—‘ï¸ ××—×§ ××—×¨×•×Ÿ
</button>
<button onclick="saveAnnotation()" class="btn btn-success" id="saveAllBtn">
ğŸ’¾ ×©××•×¨ ×”×›×œ (<span id="saveCount">0</span>)
</button>
</div>

</div>
</div>

<!-- Annotation List -->
<div id="annotationListSection" class="annotation-list hidden">
<h3>ğŸ“‹ ×¨×©×™××ª ×× ×•×˜×¦×™×•×ª</h3>
<div id="annotationListContent"></div>
</div>

<div class="controls">
<button onclick="resetUpload()" class="btn btn-primary">ğŸ”„ ×ª××•× ×” ×—×“×©×”</button>
</div>
</div>
</div>
</div>
</div>

<script>
const SUPABASE_URL = 'https://kwoiohzrzmwkxkihkogb.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imt3b2lvaHpyem13a3hraWhrb2diIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY4Mzk2MjIsImV4cCI6MjA3MjQxNTYyMn0.FK1zrvXNc-nmoV28Nr4K12MuwC_zAe5QPcZmwDSbCfw';

const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// HuggingFace Space URL
const HF_SPACE_URL = 'ankoru2025/Green';
const HF_API_TOKEN = 'tZfqDUnRvLJbPwcbzq9CWrbPaLydUx6f';

let PARAMETERS = {};
let currentUser = '';
let currentImage = null;
let selectedCategory = null;
let selectedProduct = null;
let currentParameters = {};
let isDrawing = false;
let annotations = [];
let pendingBox = null;
let mlPredictions = null;  // Store ML predictions
let startX, startY;
let selectedAnnotationIndex = null; // Track which annotation is being edited

// Polygon drawing state
let isPolygonMode = false;
let polygonPoints = [];
let fittedEllipse = null;
let isPolygonClosed = false;
let polygonReadyForClicks = false; // Flag to prevent immediate click after rectangle

// Zoom state
let zoomLevel = 1;
let zoomX = 0;
let zoomY = 0;
let isDragging = false;
let dragStartX = 0;
let dragStartY = 0;

const categories = ['avocado', 'mango', 'cucumber', 'apple', 'tomato', 'chicken_breast'];
const categoryNames = ['××‘×•×§×“×•', '×× ×’×•', '××œ×¤×¤×•×Ÿ', '×ª×¤×•×—', '×¢×’×‘× ×™×”', '×—×–×” ×¢×•×£'];

const canvas = document.getElementById('imageCanvas');
const ctx = canvas.getContext('2d');

document.addEventListener('DOMContentLoaded', function() {
initApp();
loadParametersFromSupabase();

// Check Gradio Client availability after short delay (for ES module to load)
setTimeout(() => {
    if (!window.gradioClient) {
        console.warn('âš ï¸ Gradio Client not available - ML predictions disabled');
        const msg = window.gradioClientError
            ? `ML ×œ× ×–××™×Ÿ: ${window.gradioClientError}`
            : 'ML ×œ× ×–××™×Ÿ - ×”×ª×× ×™×“× ×™×ª';
        showNotification(msg, 'error');

        // Alert on mobile
        if (/Mobi|Android|iPhone/i.test(navigator.userAgent)) {
            alert('âš ï¸ ML features not available\n\nPossible reasons:\n- Old browser version\n- Network issues\n- ES modules not supported\n\nYou can still use the app by adjusting sliders manually.');
        }
    } else {
        console.log('âœ… ML ready');
    }
}, 2000);
});

async function loadParametersFromSupabase() {
try {
const { data, error } = await supabase
.from('parameters')
.select('*');

if (error) throw error;

PARAMETERS = {};

data.forEach(row => {
if (!PARAMETERS[row.product]) {
PARAMETERS[row.product] = { visible: {}, hidden: {} };
}

PARAMETERS[row.product][row.param_type][row.param_id] = {
name: row.param_name,
min: row.min_value,
max: row.max_value,
default: row.default_value,
step: row.step_value,
gradient_class: row.gradient_class || 'linear',
left_label: row.left_label || '×’×¨×•×¢',
right_label: row.right_label || '××•×©×œ×'
};
});

console.log('Parameters loaded:', PARAMETERS);
showNotification('âœ… ×¤×¨××˜×¨×™× × ×˜×¢× ×• ×‘×”×¦×œ×—×”', 'success');

} catch (error) {
console.error('Error loading parameters:', error);
showNotification('×©×’×™××” ×‘×˜×¢×™× ×ª ×¤×¨××˜×¨×™×', 'error');
}
}

function initApp() {
const imageInput = document.getElementById('imageInput');
const cameraInput = document.getElementById('cameraInput');

// File input change handlers
imageInput.addEventListener('change', handleImageUpload);
cameraInput.addEventListener('change', handleImageUpload);

// Category button handlers
const categoryBtns = document.querySelectorAll('.category-btn');
categoryBtns.forEach(btn => {
btn.addEventListener('click', () => selectCategory(btn));
});

// Canvas drawing event handlers
canvas.addEventListener('mousedown', startDrawing);
canvas.addEventListener('mousemove', drawBoundingBox);
canvas.addEventListener('mouseup', endDrawing);

canvas.addEventListener('touchstart', handleTouch);
canvas.addEventListener('touchmove', handleTouch);
canvas.addEventListener('touchend', handleTouch);

// Initialize annotation counters
updateAnnotationCounts();

checkExistingUser();
}

function handleTouch(e) {
e.preventDefault();
const touch = e.touches[0] || e.changedTouches[0];
const mouseEvent = {
clientX: touch.clientX,
clientY: touch.clientY
};

if (e.type === 'touchstart') startDrawing(mouseEvent);
if (e.type === 'touchmove') drawBoundingBox(mouseEvent);
if (e.type === 'touchend') endDrawing(mouseEvent);
}

function checkExistingUser() {
const savedUser = localStorage.getItem('yolo_user');
if (savedUser) {
currentUser = savedUser;
document.getElementById('currentUserTop').textContent = currentUser;
showMainApp();
}
}

function login() {
const userName = document.getElementById('userName').value.trim();

if (!userName) {
showNotification('âŒ ×× × ×”×›× ×¡ ×©×', 'error');
return;
}

const englishOnlyRegex = /^[a-zA-Z]+$/;
if (!englishOnlyRegex.test(userName)) {
showNotification('âŒ ×”×©× ×—×™×™×‘ ×œ×”×›×™×œ ×¨×§ ××•×ª×™×•×ª ×× ×’×œ×™×•×ª!', 'error');
return;
}

if (userName.length < 2 || userName.length > 15) {
showNotification('âŒ ×”×©× ×—×™×™×‘ ×œ×”×™×•×ª ×‘×™×Ÿ 2-15 ××•×ª×™×•×ª', 'error');
return;
}

currentUser = userName;
localStorage.setItem('yolo_user', currentUser);
document.getElementById('currentUserTop').textContent = currentUser;
showNotification('âœ… ×©× ×ª×§×™×Ÿ! ××ª×—×™×œ...', 'success');
showMainApp();
}

function logout() {
localStorage.removeItem('yolo_user');
currentUser = '';
document.getElementById('loginSection').style.display = 'block';
document.getElementById('mainApp').style.display = 'none';
resetUpload();
}

function showMainApp() {
document.getElementById('loginSection').style.display = 'none';
document.getElementById('mainApp').style.display = 'block';
}

function handleImageUpload(e) {
const file = e.target.files[0];
if (file) {
loadImageFile(file);
}
}

function loadImageFile(file) {
if (file.size > 10 * 1024 * 1024) {
showNotification('×§×•×‘×¥ ×’×“×•×œ ××“×™ (××§×¡×™××•× 10MB)', 'error');
return;
}

const reader = new FileReader();
reader.onload = function(e) {
const img = new Image();
img.onload = function() {
currentImage = img;
setupCanvas();
drawImage();
document.getElementById('categorySection').classList.remove('hidden');
document.getElementById('canvasSection').classList.remove('hidden');
annotations = [];
};
img.src = e.target.result;
};
reader.readAsDataURL(file);
}

function setupCanvas() {
const maxWidth = Math.min(600, window.innerWidth - 40);
const maxHeight = 500;

let width = currentImage.width;
let height = currentImage.height;
const aspectRatio = width / height;

if (width > maxWidth) {
width = maxWidth;
height = width / aspectRatio;
}

if (height > maxHeight) {
height = maxHeight;
width = height * aspectRatio;
}

canvas.width = width;
canvas.height = height;
}

function drawImage() {
ctx.clearRect(0, 0, canvas.width, canvas.height);
ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);

            // Draw saved annotations (green) - THIN lines, visual only
annotations.forEach(ann => {
ctx.strokeStyle = '#00ff00';
ctx.lineWidth = 1;  // THIN LINE - visual feedback only, not saved
ctx.strokeRect(ann.x, ann.y, ann.width, ann.height);

ctx.fillStyle = '#00ff00';
ctx.font = 'bold 14px Arial';
ctx.fillText(categoryNames[ann.category], ann.x, ann.y - 5);
});

            // Draw pending box (yellow/orange - waiting for parameters) - THIN
            if (pendingBox) {
                ctx.strokeStyle = '#ffaa00';
                ctx.lineWidth = 2;  // THIN LINE
                ctx.setLineDash([10, 5]);
                ctx.strokeRect(pendingBox.x, pendingBox.y, pendingBox.width, pendingBox.height);
                ctx.setLineDash([]);

                ctx.fillStyle = '#ffaa00';
                ctx.font = 'bold 14px Arial';
                ctx.fillText(categoryNames[pendingBox.category] + ' (×”××ª×Ÿ...)', pendingBox.x, pendingBox.y - 5);
            }
}

function selectCategory(btn) {
document.querySelectorAll('.category-btn').forEach(b => b.classList.remove('selected'));
btn.classList.add('selected');
selectedCategory = parseInt(btn.dataset.category);
selectedProduct = btn.dataset.product;

// Load parameters (section will be shown when ML predictions complete)
loadParameters(selectedProduct, false);
}

function loadParameters(product, showSection = true) {
const params = PARAMETERS[product];
if (!params) {
showNotification('×¤×¨××˜×¨×™× ×¢×“×™×™×Ÿ × ×˜×¢× ×™×...', 'error');
return;
}

currentParameters = {};

// Only show parameters section if explicitly requested
if (showSection) {
    document.getElementById('parametersSection').classList.remove('hidden');
}
document.getElementById('loadingParams').classList.add('hidden');
document.getElementById('paramsContent').classList.remove('hidden');

const visibleContainer = document.getElementById('visibleParams');
const hiddenContainer = document.getElementById('hiddenParams');

visibleContainer.innerHTML = '';
hiddenContainer.innerHTML = '';

Object.entries(params.visible).forEach(([id, paramData]) => {
createParameterSlider(visibleContainer, id, paramData, 'visible');
});

Object.entries(params.hidden).forEach(([id, paramData]) => {
createParameterSlider(hiddenContainer, id, paramData, 'hidden');
});
}

function createParameterSlider(container, id, paramData, type) {
const paramItem = document.createElement('div');
paramItem.className = 'param-item';

const defaultValue = paramData.default;
currentParameters[id] = defaultValue;

const gradientClass = paramData.gradient_class || 'linear';
const leftLabel = paramData.left_label || '×’×¨×•×¢';
const rightLabel = paramData.right_label || '××•×©×œ×';

paramItem.innerHTML = `
               <div class="param-label">
                   <span>${paramData.name}</span>
                   <span class="param-value" id="value-${id}">${defaultValue.toFixed(1)}</span>
               </div>
               <div class="slider-container">
                   <input type="range" class="slider ${gradientClass}" id="slider-${id}"
                          min="${paramData.min}" max="${paramData.max}"
                          step="${paramData.step}" value="${defaultValue}">
                   <div class="slider-labels">
                       <span>${leftLabel}</span>
                       <span>${rightLabel}</span>
                   </div>
               </div>
           `;

container.appendChild(paramItem);

const slider = document.getElementById(`slider-${id}`);
slider.addEventListener('input', function(e) {
const value = parseFloat(e.target.value);
currentParameters[id] = value;
document.getElementById(`value-${id}`).textContent = value.toFixed(1);

// Auto-save if editing an existing annotation
if (selectedAnnotationIndex !== null) {
    annotations[selectedAnnotationIndex].parameters = {...currentParameters};
    updateAnnotationList();
}
});
}

function toggleGroup(groupName) {
const content = document.getElementById(`${groupName}Params`);
const icon = document.getElementById(`toggle-${groupName}`);

content.classList.toggle('collapsed');
icon.classList.toggle('collapsed');
}

function startDrawing(e) {
if (selectedCategory === null) {
showNotification('×‘×—×¨ ×§×˜×’×•×¨×™×” ×ª×—×™×œ×”', 'error');
return;
}

isDrawing = true;
const rect = canvas.getBoundingClientRect();

// Transform screen coordinates to canvas coordinates (accounting for zoom)
const scaleX = canvas.width / rect.width;
const scaleY = canvas.height / rect.height;

startX = (e.clientX - rect.left) * scaleX;
startY = (e.clientY - rect.top) * scaleY;
}

function drawBoundingBox(e) {
if (!isDrawing) return;

const rect = canvas.getBoundingClientRect();

// Transform screen coordinates to canvas coordinates (accounting for zoom)
const scaleX = canvas.width / rect.width;
const scaleY = canvas.height / rect.height;

const currentX = (e.clientX - rect.left) * scaleX;
const currentY = (e.clientY - rect.top) * scaleY;

drawImage();

ctx.strokeStyle = '#ff0000';
ctx.lineWidth = 2;
ctx.strokeRect(startX, startY, currentX - startX, currentY - startY);
}

async function getMLPredictions(x, y, width, height) {
    try {
        showNotification('ğŸ”® ×× ×ª×— ×ª××•× ×”...', 'info');

        // Check if gradioClient is loaded
        if (!window.gradioClient) {
            const reason = window.gradioClientError || 'Unknown';
            throw new Error(`Gradio Client not loaded: ${reason}`);
        }

        // Extract cropped image as blob
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = width;
        tempCanvas.height = height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(canvas, x, y, width, height, 0, 0, width, height);

        const blob = await new Promise(resolve => tempCanvas.toBlob(resolve, 'image/jpeg', 0.9));

        console.log('ğŸ” Connecting to HF Space:', HF_SPACE_URL);

        // Use Gradio Client with timeout
        const app = await Promise.race([
            window.gradioClient(HF_SPACE_URL),
            new Promise((_, reject) => setTimeout(() => reject(new Error('Connection timeout')), 15000))
        ]);

        console.log('ğŸ” Client connected. Checking endpoints...');

        // Try using index 0 (first button/endpoint)
        const result = await Promise.race([
            app.predict(0, [blob, HF_API_TOKEN]),
            new Promise((_, reject) => setTimeout(() => reject(new Error('Prediction timeout')), 20000))
        ]);

        console.log('ğŸ” Result:', result);
        console.log('ğŸ” Result.data[2]:', result.data[2]);

        // The JSON output is already parsed as object
        const predictions = result.data[2];
        console.log('ğŸ” Predictions:', predictions);

        // Store and fill sliders
        mlPredictions = {...predictions.visible_params, ...predictions.hidden_params};

        Object.entries(mlPredictions).forEach(([paramId, value]) => {
            currentParameters[paramId] = value;
            const slider = document.getElementById(`slider-${paramId}`);
            const valueDisplay = document.getElementById(`value-${paramId}`);
            if (slider && valueDisplay) {
                slider.value = value;
                valueDisplay.textContent = value.toFixed(1);
            }
        });

        // Show parameters section immediately (like index2)
        document.getElementById('parametersSection').classList.remove('hidden');

        showNotification('âœ¨ ML ×¦×¤×”! ×ª×§×Ÿ ×× ×¦×¨×™×š', 'success');

    } catch (error) {
        console.error('âŒ ML error:', error);
        mlPredictions = null;

        // More detailed error message
        let errorMsg = 'âš ï¸ ML ×œ× ×–××™×Ÿ';
        if (error.message.includes('gradioClient')) {
            errorMsg += ' (×¡×¤×¨×™×™×” ×œ× × ×˜×¢× ×”)';
        } else if (error.message.includes('timeout')) {
            errorMsg += ' (×–××Ÿ ×—×™×‘×•×¨)';
        } else if (error.message.includes('network')) {
            errorMsg += ' (×‘×¢×™×™×ª ×¨×©×ª)';
        }
        errorMsg += ' - ×”×ª×× ×™×“× ×™×ª';

        showNotification(errorMsg, 'error');

        // Show parameters section even if ML failed (like index2)
        document.getElementById('parametersSection').classList.remove('hidden');

        // Alert on mobile for easier debugging
        if (/Mobi|Android|iPhone/i.test(navigator.userAgent)) {
            setTimeout(() => {
                alert(`ML Error: ${error.message}\n\nPlease adjust sliders manually.`);
            }, 500);
        }
    }
}

function endDrawing(e) {
if (!isDrawing) return;

            // If there's already a pending box, warn user
            if (pendingBox) {
                showNotification('âš ï¸ ×©××•×¨ ××ª ×”×× ×•×˜×¦×™×” ×”× ×•×›×—×™×ª ×œ×¤× ×™ ×¦×™×•×¨ ×—×“×©', 'error');
                isDrawing = false;
                return;
            }

isDrawing = false;
const rect = canvas.getBoundingClientRect();

// Transform screen coordinates to canvas coordinates (accounting for zoom)
const scaleX = canvas.width / rect.width;
const scaleY = canvas.height / rect.height;

const endX = (e.clientX - rect.left) * scaleX;
const endY = (e.clientY - rect.top) * scaleY;

const x = Math.min(startX, endX);
const y = Math.min(startY, endY);
const width = Math.abs(endX - startX);
const height = Math.abs(endY - startY);

if (width > 20 && height > 20) {
                // Store pending box - DON'T save parameters yet!
                pendingBox = {
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    category: selectedCategory,
                    product: selectedProduct
                };

                // Show the "Add Annotation" and "Delete" buttons
                document.getElementById('addAnnotationBtn').style.display = 'inline-block';
                document.getElementById('deleteBtn').style.display = 'inline-block';

                // Draw the box temporarily
                drawImage();

                // Get ML predictions - this will show sliders immediately (like index2)
                getMLPredictions(x, y, width, height);

                // ALSO enter polygon tracing mode for optional refinement
                enterPolygonMode(x, y, width, height);
}
}

        function updateAnnotationCounts() {
            const count = annotations.length;
            document.getElementById('annotationCount').textContent = count;
            document.getElementById('saveCount').textContent = count;

            // Disable/enable save button based on count
            const saveBtn = document.getElementById('saveAllBtn');
            if (count === 0) {
                saveBtn.disabled = true;
                saveBtn.style.opacity = '0.5';
                saveBtn.style.cursor = 'not-allowed';
            } else {
                saveBtn.disabled = false;
                saveBtn.style.opacity = '1';
                saveBtn.style.cursor = 'pointer';
            }

            // Update annotation list
            updateAnnotationList();
        }

        function updateAnnotationList() {
            const listSection = document.getElementById('annotationListSection');
            const listContent = document.getElementById('annotationListContent');

            if (annotations.length === 0) {
                listSection.classList.add('hidden');
                return;
            }

            listSection.classList.remove('hidden');
            listContent.innerHTML = '';

            annotations.forEach((ann, index) => {
                // Calculate overall score (average of all parameters)
                const params = ann.parameters;
                const scores = Object.values(params);
                const avgScore = scores.reduce((a, b) => a + b, 0) / scores.length;

                const item = document.createElement('div');
                item.className = 'annotation-item';
                if (selectedAnnotationIndex === index) {
                    item.classList.add('selected');
                }

                item.innerHTML = `
                    <div class="annotation-item-info">
                        <div class="annotation-item-title">Polygon ${index + 1} - ${categoryNames[ann.category]}</div>
                        <div class="annotation-item-score">Total Score: ${avgScore.toFixed(1)}</div>
                    </div>
                    <div class="annotation-item-actions">
                        <button class="annotation-item-btn edit" onclick="editAnnotation(${index})">âœï¸</button>
                        <button class="annotation-item-btn delete" onclick="deleteAnnotationFromList(${index})">ğŸ—‘ï¸</button>
                    </div>
                `;

                listContent.appendChild(item);
            });
        }

        function editAnnotation(index) {
            if (index < 0 || index >= annotations.length) return;

            selectedAnnotationIndex = index;
            const ann = annotations[index];

            // Load the annotation's parameters into sliders
            currentParameters = {...ann.parameters};
            selectedProduct = ann.product;

            // Update slider values
            Object.entries(currentParameters).forEach(([paramId, value]) => {
                const slider = document.getElementById(`slider-${paramId}`);
                const valueDisplay = document.getElementById(`value-${paramId}`);
                if (slider && valueDisplay) {
                    slider.value = value;
                    valueDisplay.textContent = value.toFixed(1);
                }
            });

            // Show parameters section
            document.getElementById('parametersSection').classList.remove('hidden');

            // Update list to show selection
            updateAnnotationList();

            // Show preview
            showAnnotationPreview(ann);

            showNotification(`ğŸ“ ×¢×•×¨×š Polygon ${index + 1}`, 'success');
        }

        function showAnnotationPreview(ann) {
            if (!ann.ellipse) return;

            const previewCanvas = document.getElementById('previewCanvas');
            const previewCtx = previewCanvas.getContext('2d');

            // Create crop with padding
            const PADDING = 1.15;
            const centerX = ann.x + ann.width / 2;
            const centerY = ann.y + ann.height / 2;

            const x1 = Math.max(0, centerX - (ann.width / 2) * PADDING);
            const y1 = Math.max(0, centerY - (ann.height / 2) * PADDING);
            const x2 = Math.min(canvas.width, centerX + (ann.width / 2) * PADDING);
            const y2 = Math.min(canvas.height, centerY + (ann.height / 2) * PADDING);

            const cropWidth = x2 - x1;
            const cropHeight = y2 - y1;

            // Create temp canvas for crop
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = cropWidth;
            tempCanvas.height = cropHeight;
            const tempCtx = tempCanvas.getContext('2d');

            // Draw crop from current image
            tempCtx.drawImage(currentImage, x1, y1, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);

            // Transform ellipse to crop space
            const ellipseInCropSpace = {
                cx: ann.ellipse.cx - x1,
                cy: ann.ellipse.cy - y1,
                rx: ann.ellipse.rx,
                ry: ann.ellipse.ry,
                angle: ann.ellipse.angle
            };

            // Apply ellipse mask
            const GRAY = 128;
            const maskCanvas = document.createElement('canvas');
            maskCanvas.width = cropWidth;
            maskCanvas.height = cropHeight;
            const maskCtx = maskCanvas.getContext('2d');

            // Draw ellipse on mask
            maskCtx.fillStyle = 'white';
            maskCtx.fillRect(0, 0, cropWidth, cropHeight);
            maskCtx.fillStyle = 'black';
            maskCtx.save();
            maskCtx.translate(ellipseInCropSpace.cx, ellipseInCropSpace.cy);
            maskCtx.rotate(ellipseInCropSpace.angle);
            maskCtx.beginPath();
            maskCtx.ellipse(0, 0, ellipseInCropSpace.rx, ellipseInCropSpace.ry, 0, 0, 2 * Math.PI);
            maskCtx.fill();
            maskCtx.restore();

            // Apply mask
            const imageData = tempCtx.getImageData(0, 0, cropWidth, cropHeight);
            const maskData = maskCtx.getImageData(0, 0, cropWidth, cropHeight);

            for (let i = 0; i < imageData.data.length; i += 4) {
                if (maskData.data[i] > 128) {  // Outside ellipse
                    imageData.data[i] = GRAY;
                    imageData.data[i + 1] = GRAY;
                    imageData.data[i + 2] = GRAY;
                }
            }

            tempCtx.putImageData(imageData, 0, 0);

            // Draw to preview canvas (scaled to fit)
            const scale = Math.min(150 / cropWidth, 150 / cropHeight);
            const drawWidth = cropWidth * scale;
            const drawHeight = cropHeight * scale;

            previewCanvas.width = drawWidth;
            previewCanvas.height = drawHeight;
            previewCtx.drawImage(tempCanvas, 0, 0, cropWidth, cropHeight, 0, 0, drawWidth, drawHeight);

            previewCanvas.classList.add('active');
        }

        function deleteAnnotationFromList(index) {
            if (index < 0 || index >= annotations.length) return;

            annotations.splice(index, 1);

            // Clear selection if deleted annotation was selected
            if (selectedAnnotationIndex === index) {
                selectedAnnotationIndex = null;
                document.getElementById('previewCanvas').classList.remove('active');
            } else if (selectedAnnotationIndex > index) {
                selectedAnnotationIndex--;
            }

            updateAnnotationCounts();
            drawImage();
            showNotification('ğŸ—‘ï¸ × ××—×§ ××”×¨×©×™××”', 'info');
        }

        function saveEditedAnnotation() {
            if (selectedAnnotationIndex === null) return;

            // Update the annotation with current parameter values
            annotations[selectedAnnotationIndex].parameters = {...currentParameters};

            // Clear selection
            selectedAnnotationIndex = null;

            updateAnnotationList();
            showNotification('âœ… ×¢×•×“×›×Ÿ ×‘×¨×©×™××”', 'success');
        }

        function addCurrentAnnotation() {
            if (!pendingBox) {
                showNotification('âš ï¸ ×œ× × ××¦××” ×× ×•×˜×¦×™×” ×××ª×™× ×”', 'error');
                return;
            }

            // Check if user corrected ML
            let userCorrected = false;
            let corrections = {};

            if (mlPredictions) {
                for (const [paramId, mlValue] of Object.entries(mlPredictions)) {
                    const userValue = currentParameters[paramId];
                    if (userValue !== undefined && Math.abs(userValue - mlValue) > 0.1) {
                        userCorrected = true;
                        corrections[paramId] = userValue - mlValue;
                    }
                }
            }

            // Flag for manual ellipse if polygon was used
            const hasManualEllipse = pendingBox.ellipse ? true : false;

            // Save with ML metadata AND manual ellipse flag
            annotations.push({
                ...pendingBox,
                parameters: {...currentParameters},
                ml_predictions: mlPredictions ? {...mlPredictions} : null,
                user_corrected: userCorrected,
                corrections: Object.keys(corrections).length > 0 ? corrections : null,
                has_manual_ellipse: hasManualEllipse,
                annotation_source: 'index4'
            });

            // Clear
            pendingBox = null;
            mlPredictions = null;
            selectedAnnotationIndex = null; // Clear any edit selection

            // Hide add button
            document.getElementById('addAnnotationBtn').style.display = 'none';

            // Reset parameters (keep section visible for next annotation - like index2)
            loadParameters(selectedProduct);

            // Update annotation counters and list
            updateAnnotationCounts();

            // Ensure we're in rectangle drawing mode and zoomed out
            if (isPolygonMode) {
                exitPolygonMode();
            }

            drawImage();

            const msg = userCorrected ?
                `âœ… ×”×•×¡×£ ×œ×¨×©×™××”! ×¡×”"×› ${annotations.length}` :
                `âœ… ×”×•×¡×£ ×œ×¨×©×™××”! ×¡×”"×› ${annotations.length}`;
            showNotification(msg, 'success');

            // Hide delete button but keep parameters visible for next annotation
            document.getElementById('deleteBtn').style.display = 'none';
        }

        function deleteLastBox() {
            const wasInPolygonMode = isPolygonMode;

            if (pendingBox) {
                pendingBox = null;
                mlPredictions = null;

                // Exit polygon mode if active
                if (isPolygonMode) {
                    exitPolygonMode();
                }

                // Hide delete and add buttons
                document.getElementById('deleteBtn').style.display = 'none';
                document.getElementById('addAnnotationBtn').style.display = 'none';

                // Hide preview
                document.getElementById('previewCanvas').classList.remove('active');

                // Reset parameters
                loadParameters(selectedProduct);
                drawImage();
                showNotification('××—×™×§×ª ××¡×’×¨×ª', 'info');

                // Ready for immediate new drawing
                isDrawing = false;
            } else if (annotations.length > 0) {
                annotations.pop();
                updateAnnotationCounts();
                drawImage();
                showNotification('× ××—×§', 'info');
            }
        }

        function updatePreview() {
            if (!pendingBox) {
                document.getElementById('previewCanvas').classList.remove('active');
                return;
            }

            const previewCanvas = document.getElementById('previewCanvas');
            const previewCtx = previewCanvas.getContext('2d');

            // Only show preview if we have an ellipse
            if (!pendingBox.ellipse) {
                previewCanvas.classList.remove('active');
                return;
            }

            // Create crop with padding
            const PADDING = 1.15;
            const centerX = pendingBox.x + pendingBox.width / 2;
            const centerY = pendingBox.y + pendingBox.height / 2;

            const x1 = Math.max(0, centerX - (pendingBox.width / 2) * PADDING);
            const y1 = Math.max(0, centerY - (pendingBox.height / 2) * PADDING);
            const x2 = Math.min(canvas.width, centerX + (pendingBox.width / 2) * PADDING);
            const y2 = Math.min(canvas.height, centerY + (pendingBox.height / 2) * PADDING);

            const cropWidth = x2 - x1;
            const cropHeight = y2 - y1;

            // Create temp canvas for crop
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = cropWidth;
            tempCanvas.height = cropHeight;
            const tempCtx = tempCanvas.getContext('2d');

            // Draw crop from current image
            tempCtx.drawImage(currentImage, x1, y1, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);

            // Transform ellipse to crop space
            const ellipseInCropSpace = {
                cx: pendingBox.ellipse.cx - x1,
                cy: pendingBox.ellipse.cy - y1,
                rx: pendingBox.ellipse.rx,
                ry: pendingBox.ellipse.ry,
                angle: pendingBox.ellipse.angle
            };

            // Apply ellipse mask
            const GRAY = 128;
            const maskCanvas = document.createElement('canvas');
            maskCanvas.width = cropWidth;
            maskCanvas.height = cropHeight;
            const maskCtx = maskCanvas.getContext('2d');

            // Draw ellipse on mask
            maskCtx.fillStyle = 'white';
            maskCtx.fillRect(0, 0, cropWidth, cropHeight);
            maskCtx.fillStyle = 'black';
            maskCtx.save();
            maskCtx.translate(ellipseInCropSpace.cx, ellipseInCropSpace.cy);
            maskCtx.rotate(ellipseInCropSpace.angle);
            maskCtx.beginPath();
            maskCtx.ellipse(0, 0, ellipseInCropSpace.rx, ellipseInCropSpace.ry, 0, 0, 2 * Math.PI);
            maskCtx.fill();
            maskCtx.restore();

            // Apply mask
            const imageData = tempCtx.getImageData(0, 0, cropWidth, cropHeight);
            const maskData = maskCtx.getImageData(0, 0, cropWidth, cropHeight);

            for (let i = 0; i < imageData.data.length; i += 4) {
                if (maskData.data[i] > 128) {  // Outside ellipse
                    imageData.data[i] = GRAY;
                    imageData.data[i + 1] = GRAY;
                    imageData.data[i + 2] = GRAY;
                }
            }

            tempCtx.putImageData(imageData, 0, 0);

            // Draw to preview canvas (scaled to fit)
            const scale = Math.min(150 / cropWidth, 150 / cropHeight);
            const drawWidth = cropWidth * scale;
            const drawHeight = cropHeight * scale;

            previewCanvas.width = drawWidth;
            previewCanvas.height = drawHeight;
            previewCtx.drawImage(tempCanvas, 0, 0, cropWidth, cropHeight, 0, 0, drawWidth, drawHeight);

            previewCanvas.classList.add('active');
        }

function clearCanvas() {
annotations = [];
            pendingBox = null;
            mlPredictions = null;
            selectedAnnotationIndex = null;
            document.getElementById('addAnnotationBtn').style.display = 'none';
            document.getElementById('deleteBtn').style.display = 'none';
            document.getElementById('previewCanvas').classList.remove('active');
            updateAnnotationCounts();
drawImage();
            showNotification('× ×•×§×” ×”×›×œ', 'success');
}

function resetUpload() {
currentImage = null;
selectedCategory = null;
selectedProduct = null;
currentParameters = {};
annotations = [];
            pendingBox = null;
            mlPredictions = null;
            selectedAnnotationIndex = null;
            document.getElementById('addAnnotationBtn').style.display = 'none';
            document.getElementById('deleteBtn').style.display = 'none';
            document.getElementById('previewCanvas').classList.remove('active');
            updateAnnotationCounts();
document.getElementById('categorySection').classList.add('hidden');
document.getElementById('canvasSection').classList.add('hidden');
document.getElementById('parametersSection').classList.add('hidden');
document.getElementById('loadingParams').classList.remove('hidden');
document.getElementById('paramsContent').classList.add('hidden');
document.getElementById('imageInput').value = '';
document.getElementById('cameraInput').value = '';
document.querySelectorAll('.category-btn').forEach(b => b.classList.remove('selected'));
}

async function saveAnnotation() {
if (!currentImage || annotations.length === 0) {
showNotification('××™×Ÿ ×× ×•×˜×¦×™×•×ª ×œ×©××•×¨', 'error');
return;
}

try {
showNotification('×©×•××¨...', 'success');

// Create source canvas with ORIGINAL image (no annotations drawn)
const sourceCanvas = document.createElement('canvas');
sourceCanvas.width = canvas.width;
sourceCanvas.height = canvas.height;
const sourceCtx = sourceCanvas.getContext('2d');
sourceCtx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);

const timestamp = Date.now();
const baseFileName = `${timestamp}_${currentUser.toLowerCase()}`;

// Upload the full original image (for mask_db_ellipses.py to process non-manual annotations)
const fullImageBlob = await new Promise(resolve => sourceCanvas.toBlob(resolve, 'image/jpeg', 0.85));
const fullImageFileName = `${baseFileName}.jpg`;

const { error: fullImageError } = await supabase.storage
    .from('images')
    .upload(fullImageFileName, fullImageBlob);

if (fullImageError) {
    throw new Error(`Upload failed for full image: ${fullImageError.message}`);
}

// Process each annotation individually
const yoloAnnotations = [];

for (let i = 0; i < annotations.length; i++) {
    const ann = annotations[i];

    // Create crop with padding (matching mask_db_ellipses.py ELLIPSE_PADDING = 1.15)
    const PADDING = 1.15;
    const centerX = ann.x + ann.width / 2;
    const centerY = ann.y + ann.height / 2;

    const x1 = Math.max(0, centerX - (ann.width / 2) * PADDING);
    const y1 = Math.max(0, centerY - (ann.height / 2) * PADDING);
    const x2 = Math.min(canvas.width, centerX + (ann.width / 2) * PADDING);
    const y2 = Math.min(canvas.height, centerY + (ann.height / 2) * PADDING);

    const cropWidth = x2 - x1;
    const cropHeight = y2 - y1;

    // Only create and upload masked crop if manual ellipse was used
    let cropFileName = null;

    if (ann.has_manual_ellipse && ann.ellipse) {
        // Extract crop from source image
        const cropCanvas = document.createElement('canvas');
        cropCanvas.width = cropWidth;
        cropCanvas.height = cropHeight;
        const cropCtx = cropCanvas.getContext('2d');
        cropCtx.drawImage(sourceCanvas, x1, y1, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);

        // Transform ellipse coordinates from canvas space to crop space
        const ellipseInCropSpace = {
            cx: ann.ellipse.cx - x1,
            cy: ann.ellipse.cy - y1,
            rx: ann.ellipse.rx,
            ry: ann.ellipse.ry,
            angle: ann.ellipse.angle
        };
        applyEllipseMask(cropCanvas, cropCtx, ellipseInCropSpace, cropWidth, cropHeight);

        // Upload masked crop (using same naming as mask_db_ellipses.py)
        const blob = await new Promise(resolve => cropCanvas.toBlob(resolve, 'image/jpeg', 0.85));
        cropFileName = `${baseFileName}_ann${i}_masked.jpg`;

        const { error: uploadError } = await supabase.storage
            .from('images')
            .upload(cropFileName, blob);

        if (uploadError) {
            throw new Error(`Upload failed for crop ${i}: ${uploadError.message}`);
        }
    }
    // Otherwise, mask_db_ellipses.py will create masked crops later

    // Save YOLO annotation (still using original coordinates for reference)
    const annotationData = {
        category: ann.category,
        product: ann.product,
        center_x: (ann.x + ann.width / 2) / canvas.width,
        center_y: (ann.y + ann.height / 2) / canvas.height,
        width: ann.width / canvas.width,
        height: ann.height / canvas.height,
        parameters: ann.parameters,
        ml_predictions: ann.ml_predictions,
        user_corrected: ann.user_corrected,
        corrections: ann.corrections,
        has_manual_ellipse: ann.has_manual_ellipse,
        annotation_source: ann.annotation_source
    };

    // Add ellipse data if manual polygon was used
    if (ann.has_manual_ellipse && ann.ellipse) {
        annotationData.ellipse_params = {
            cx: ann.ellipse.cx / canvas.width,  // Normalized to [0,1]
            cy: ann.ellipse.cy / canvas.height,
            rx: ann.ellipse.rx / canvas.width,
            ry: ann.ellipse.ry / canvas.height,
            angle: ann.ellipse.angle
        };
        annotationData.masked_image_path = cropFileName;
    }

    yoloAnnotations.push(annotationData);
}

// Save to database
const { data, error } = await supabase
.from('annotations')
.insert([{
user_name: currentUser,
image_path: fullImageFileName,  // Full original image (for mask_db_ellipses.py)
annotations: yoloAnnotations,
created_at: new Date().toISOString()
}]);

if (error) {
throw new Error(`Database save failed: ${error.message}`);
}

showNotification(`âœ… × ×©××¨ ×‘×”×¦×œ×—×”! ${annotations.length} ××•×‘×™×™×§×˜×™×`, 'success');

// Clear saved annotations but keep image loaded for more annotations
annotations = [];
updateAnnotationCounts();
drawImage();

} catch (error) {
console.error('Error:', error);
showNotification(`×©×’×™××”: ${error.message}`, 'error');
saveLocally();
}
}

// Apply ellipse mask to crop (matching mask_db_ellipses.py)
function applyEllipseMask(canvas, ctx, ellipse, cropWidth, cropHeight) {
    // Gray background color (matching mask_db_ellipses.py: ELLIPSE_FILL_COLOR = (128, 128, 128))
    const GRAY = 128;

    // Create mask canvas
    const maskCanvas = document.createElement('canvas');
    maskCanvas.width = cropWidth;
    maskCanvas.height = cropHeight;
    const maskCtx = maskCanvas.getContext('2d');

    // Draw ellipse on mask
    maskCtx.fillStyle = 'white';
    maskCtx.fillRect(0, 0, cropWidth, cropHeight);
    maskCtx.fillStyle = 'black';
    maskCtx.save();
    maskCtx.translate(ellipse.cx, ellipse.cy);
    maskCtx.rotate(ellipse.angle);
    maskCtx.beginPath();
    maskCtx.ellipse(0, 0, ellipse.rx, ellipse.ry, 0, 0, 2 * Math.PI);
    maskCtx.fill();
    maskCtx.restore();

    // Get image data
    const imageData = ctx.getImageData(0, 0, cropWidth, cropHeight);
    const maskData = maskCtx.getImageData(0, 0, cropWidth, cropHeight);

    // Apply mask: gray background outside ellipse, original inside
    for (let i = 0; i < imageData.data.length; i += 4) {
        if (maskData.data[i] > 128) {  // Outside ellipse (white in mask)
            imageData.data[i] = GRAY;      // R
            imageData.data[i + 1] = GRAY;  // G
            imageData.data[i + 2] = GRAY;  // B
        }
        // Inside ellipse: keep original pixel values
    }

    // Put masked data back
    ctx.putImageData(imageData, 0, 0);
}

function saveLocally() {
const localData = JSON.parse(localStorage.getItem('yolo_dataset') || '[]');

// Map annotations with full metadata (matching online save)
const yoloAnnotations = annotations.map(ann => {
    const annotationData = {
        category: ann.category,
        product: ann.product,
        center_x: (ann.x + ann.width / 2) / canvas.width,
        center_y: (ann.y + ann.height / 2) / canvas.height,
        width: ann.width / canvas.width,
        height: ann.height / canvas.height,
        parameters: ann.parameters,
        ml_predictions: ann.ml_predictions,
        user_corrected: ann.user_corrected,
        corrections: ann.corrections,
        has_manual_ellipse: ann.has_manual_ellipse,
        annotation_source: ann.annotation_source
    };

    // Add ellipse params if manual polygon was used
    if (ann.has_manual_ellipse && ann.ellipse) {
        annotationData.ellipse_params = {
            cx: ann.ellipse.cx / canvas.width,
            cy: ann.ellipse.cy / canvas.height,
            rx: ann.ellipse.rx / canvas.width,
            ry: ann.ellipse.ry / canvas.height,
            angle: ann.ellipse.angle
        };
    }

    return annotationData;
});

// Save ORIGINAL image WITHOUT annotation lines
const tempCanvas = document.createElement('canvas');
tempCanvas.width = canvas.width;
tempCanvas.height = canvas.height;
const tempCtx = tempCanvas.getContext('2d');
tempCtx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);

localData.push({
id: Date.now(),
user_name: currentUser,
annotations: yoloAnnotations,
image_data: tempCanvas.toDataURL('image/jpeg', 0.8),
created_at: new Date().toISOString()
});

localStorage.setItem('yolo_dataset', JSON.stringify(localData));
showNotification('ğŸ’¾ × ×©××¨ ××§×•××™×ª ×‘×˜×œ×¤×•×Ÿ', 'success');

// Clear saved annotations but keep image loaded for more annotations
annotations = [];
updateAnnotationCounts();
drawImage();
}

function showNotification(message, type) {
const existing = document.querySelector('.notification');
if (existing) existing.remove();

const notification = document.createElement('div');
notification.className = 'notification ' + type;
notification.textContent = message;
document.body.appendChild(notification);

setTimeout(() => notification.classList.add('show'), 100);

setTimeout(() => {
notification.classList.remove('show');
setTimeout(() => notification.remove(), 300);
}, 4000);
}

// ============================================
// ZOOM FUNCTIONS
// ============================================

function zoomIn() {
    zoomLevel = Math.min(zoomLevel * 1.5, 5);
    applyZoom();
}

function zoomOut() {
    zoomLevel = Math.max(zoomLevel / 1.5, 1);
    applyZoom();
}

function resetZoom() {
    zoomLevel = 1;
    zoomX = 0;
    zoomY = 0;
    applyZoom();
}

function applyZoom() {
    const wrapper = document.getElementById('canvasWrapper');
    wrapper.style.transform = `translate(${zoomX}px, ${zoomY}px) scale(${zoomLevel})`;

    // Reposition buttons if they're visible
    if (isPolygonClosed && fittedEllipse) {
        positionPolygonControls();
    }
}

// Mouse wheel zoom
canvas.addEventListener('wheel', (e) => {
    if (!isPolygonMode) return;
    e.preventDefault();

    if (e.deltaY < 0) {
        zoomIn();
    } else {
        zoomOut();
    }
});

// ============================================
// POLYGON DRAWING FUNCTIONS
// ============================================

function enterPolygonMode(x, y, width, height) {
    isPolygonMode = true;
    polygonPoints = []; // Start with EMPTY array - user will click to add first point
    fittedEllipse = null;
    isPolygonClosed = false;
    polygonReadyForClicks = false; // NOT ready yet - prevent immediate clicks

    // Auto-zoom to rectangle area
    const padding = 50;
    const rectCenterX = x + width / 2;
    const rectCenterY = y + height / 2;

    // Calculate zoom to fit rectangle nicely
    const canvasWidth = canvas.width;
    const canvasHeight = canvas.height;
    const zoomX_factor = canvasWidth / (width + padding * 2);
    const zoomY_factor = canvasHeight / (height + padding * 2);
    zoomLevel = Math.min(zoomX_factor, zoomY_factor, 3);

    // Center on rectangle
    zoomX = (canvasWidth / 2 - rectCenterX) * zoomLevel;
    zoomY = (canvasHeight / 2 - rectCenterY) * zoomLevel;

    applyZoom();

    // Show controls (but NOT polygon buttons yet - only after closing polygon)
    document.getElementById('zoomControls').classList.add('active');
    document.getElementById('polygonInfo').classList.add('active');
    canvas.classList.add('polygon-mode');

    // Remove rectangle drawing handlers, add polygon handlers
    canvas.removeEventListener('mousedown', startDrawing);
    canvas.removeEventListener('mousemove', drawBoundingBox);
    canvas.removeEventListener('mouseup', endDrawing);

    canvas.addEventListener('click', addPolygonPoint);
    canvas.addEventListener('dblclick', closePolygon);

    // Add touch support for polygon tracing on mobile
    canvas.addEventListener('touchend', handlePolygonTouch);

    drawImage();

    // Wait for zoom animation to complete, THEN allow polygon clicks
    setTimeout(() => {
        polygonReadyForClicks = true;
        showNotification('ğŸ¯ Click to trace polygon (or skip and click Add button)', 'success');
    }, 300); // 300ms delay to ensure rectangle drawing is complete and zoom is visible
}

function exitPolygonMode() {
    isPolygonMode = false;
    polygonPoints = [];
    fittedEllipse = null;
    isPolygonClosed = false;
    polygonReadyForClicks = false;

    // Reset zoom
    resetZoom();

    // Hide controls
    document.getElementById('zoomControls').classList.remove('active');
    document.getElementById('polygonInfo').classList.remove('active');
    document.getElementById('polygonControls').classList.remove('active');
    canvas.classList.remove('polygon-mode');

    // Restore rectangle drawing handlers
    canvas.removeEventListener('click', addPolygonPoint);
    canvas.removeEventListener('dblclick', closePolygon);
    canvas.removeEventListener('touchend', handlePolygonTouch);

    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', drawBoundingBox);
    canvas.addEventListener('mouseup', endDrawing);

    drawImage();
}

function handlePolygonTouch(e) {
    if (!isPolygonMode || isPolygonClosed) return;

    e.preventDefault();
    const touch = e.changedTouches[0];

    // Create a synthetic click event
    const clickEvent = {
        clientX: touch.clientX,
        clientY: touch.clientY,
        preventDefault: () => {}
    };

    addPolygonPoint(clickEvent);
}

function addPolygonPoint(e) {
    if (!isPolygonMode || isPolygonClosed) return;

    // WAIT for zoom to complete before accepting clicks
    if (!polygonReadyForClicks) {
        return; // Ignore clicks until ready
    }

    // Get canvas bounding rect (this includes the transform)
    const rect = canvas.getBoundingClientRect();

    // Calculate click position relative to canvas element
    // rect.width/height are the DISPLAYED dimensions (after transform)
    // canvas.width/height are the ACTUAL canvas dimensions
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;

    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;

    // Check if clicking near start point to close polygon
    if (polygonPoints.length >= 3) {
        const first = polygonPoints[0];
        const dist = Math.sqrt((x - first.x) ** 2 + (y - first.y) ** 2);
        if (dist < 15) {
            closePolygon(e);
            return;
        }
    }

    polygonPoints.push({x, y});
    document.getElementById('pointCount').textContent = polygonPoints.length;

    drawImage();
}

function closePolygon(e) {
    if (polygonPoints.length < 3) {
        showNotification('Need at least 3 points', 'error');
        return;
    }

    if (e) e.preventDefault();

    isPolygonClosed = true;

    // Fit ellipse to polygon
    fittedEllipse = fitEllipseToPolygon(polygonPoints);

    // Draw the ellipse FIRST
    drawImage();

    // Position buttons next to the ellipse and show them IMMEDIATELY
    positionPolygonControls();
    document.getElementById('polygonControls').classList.add('active');

    showNotification('âœ“ Ellipse suggested! Accept âœ“ or Retry ğŸ”„', 'success');
}

function positionPolygonControls() {
    if (!polygonPoints || polygonPoints.length === 0) return;

    const controls = document.getElementById('polygonControls');

    // Find the bottom-most point of the polygon
    let maxY = -Infinity;
    let sumX = 0;
    for (const p of polygonPoints) {
        if (p.y > maxY) maxY = p.y;
        sumX += p.x;
    }
    const centerX = sumX / polygonPoints.length;

    // Position DIRECTLY TOUCHING below the polygon's lowest point
    // Account for current zoom and pan
    const screenY = maxY * zoomLevel + zoomY + 5; // 5px below polygon (touching)

    // Position controls at the bottom of polygon, centered
    controls.style.top = `${screenY}px`;

    // Keep centered horizontally (already set in CSS with left: 50%)
}

function undoLastPoint() {
    if (polygonPoints.length > 0 && !isPolygonClosed) {
        polygonPoints.pop();
        document.getElementById('pointCount').textContent = polygonPoints.length;
        drawImage();
    }
}

function retryPolygon() {
    polygonPoints = [];
    fittedEllipse = null;
    isPolygonClosed = false;
    polygonReadyForClicks = true; // Keep it ready since we're already zoomed
    document.getElementById('pointCount').textContent = 0;

    // Hide buttons when retrying
    document.getElementById('polygonControls').classList.remove('active');

    drawImage();
    showNotification('Retry: Click to draw new polygon', 'success');
}

function acceptPolygon() {
    if (!isPolygonClosed || !fittedEllipse) {
        showNotification('Please close the polygon first', 'error');
        return;
    }

    // Update pending box with ellipse parameters
    if (pendingBox) {
        pendingBox.ellipse = fittedEllipse;
        pendingBox.polygon = [...polygonPoints];
    }

    // Exit polygon mode (this resets zoom to 1:1)
    exitPolygonMode();

    // Parameters section is ALREADY shown (from endDrawing), no need to show again
    // Add button is ALREADY shown

    // Draw the result at 1:1 zoom
    drawImage();

    // Update preview with masked crop in right panel
    updatePreview();

    showNotification('âœ“ ××œ×™×¤×¡×” ×”×ª×§×‘×œ×”! ×‘×“×•×§ ×¤×¨××˜×¨×™× ×•×œ×—×¥ ×”×•×¡×£', 'success');
}

// ============================================
// ELLIPSE FITTING ALGORITHM (Fitzgibbon Direct Least Squares)
// ============================================

function fitEllipseToPolygon(points) {
    if (points.length < 5) {
        // Need at least 5 points to fit ellipse
        // Fall back to simple bbox ellipse
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        for (const p of points) {
            minX = Math.min(minX, p.x);
            maxX = Math.max(maxX, p.x);
            minY = Math.min(minY, p.y);
            maxY = Math.max(maxY, p.y);
        }
        return {
            cx: (minX + maxX) / 2,
            cy: (minY + maxY) / 2,
            rx: (maxX - minX) / 2,
            ry: (maxY - minY) / 2,
            angle: 0
        };
    }

    // Calculate center of mass
    let cx = 0, cy = 0;
    for (const p of points) {
        cx += p.x;
        cy += p.y;
    }
    cx /= points.length;
    cy /= points.length;

    // Simplified ellipse fitting:
    // Calculate moments to get orientation and size
    let mxx = 0, myy = 0, mxy = 0;
    for (const p of points) {
        const dx = p.x - cx;
        const dy = p.y - cy;
        mxx += dx * dx;
        myy += dy * dy;
        mxy += dx * dy;
    }
    mxx /= points.length;
    myy /= points.length;
    mxy /= points.length;

    // Calculate angle
    const angle = 0.5 * Math.atan2(2 * mxy, mxx - myy);

    // Calculate semi-axes
    const cos_a = Math.cos(angle);
    const sin_a = Math.sin(angle);

    let rx_sq = 0, ry_sq = 0;
    for (const p of points) {
        const dx = p.x - cx;
        const dy = p.y - cy;
        const dx_rot = dx * cos_a + dy * sin_a;
        const dy_rot = -dx * sin_a + dy * cos_a;
        rx_sq += dx_rot * dx_rot;
        ry_sq += dy_rot * dy_rot;
    }

    const rx = Math.sqrt(rx_sq / points.length) * 2;
    const ry = Math.sqrt(ry_sq / points.length) * 2;

    // Scale down to fit INSIDE polygon - matching mask_db_ellipses.py ELLIPSE_SIZE_FACTOR
    const scaleFactor = 0.6;

    return {
        cx: cx,
        cy: cy,
        rx: Math.max(rx, ry) * scaleFactor,  // Semi-major axis (scaled to fit inside)
        ry: Math.min(rx, ry) * scaleFactor,  // Semi-minor axis (scaled to fit inside)
        angle: angle
    };
}

// ============================================
// MODIFIED DRAW IMAGE FUNCTION
// ============================================

// Override the existing drawImage to include polygon and ellipse drawing
const originalDrawImage = drawImage;
drawImage = function() {
    originalDrawImage();

    // Draw polygon if in polygon mode
    if (isPolygonMode && polygonPoints.length > 0) {
        ctx.save();
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 2;
        ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';

        ctx.beginPath();
        ctx.moveTo(polygonPoints[0].x, polygonPoints[0].y);
        for (let i = 1; i < polygonPoints.length; i++) {
            ctx.lineTo(polygonPoints[i].x, polygonPoints[i].y);
        }

        if (isPolygonClosed) {
            ctx.closePath();
            ctx.fill();
        } else {
            // Draw preview line to cursor or start
            ctx.lineTo(polygonPoints[0].x, polygonPoints[0].y);
            ctx.setLineDash([5, 5]);
        }

        ctx.stroke();
        ctx.setLineDash([]);

        // Draw points
        ctx.fillStyle = '#00ff00';
        for (const p of polygonPoints) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI);
            ctx.fill();
        }

        // Highlight start point
        if (polygonPoints.length > 0) {
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(polygonPoints[0].x, polygonPoints[0].y, 10, 0, 2 * Math.PI);
            ctx.stroke();
        }

        ctx.restore();

        // Draw fitted ellipse if closed - Show gray OUTSIDE ellipse, fruit INSIDE
        if (isPolygonClosed && fittedEllipse) {
            ctx.save();

            // Create clipping path from polygon
            ctx.beginPath();
            ctx.moveTo(polygonPoints[0].x, polygonPoints[0].y);
            for (let i = 1; i < polygonPoints.length; i++) {
                ctx.lineTo(polygonPoints[i].x, polygonPoints[i].y);
            }
            ctx.closePath();
            ctx.clip(); // Clip to polygon boundary

            // Fill entire polygon area with gray (matching mask_db_ellipses.py: 128,128,128)
            ctx.fillStyle = 'rgba(128, 128, 128, 0.85)';
            ctx.fill();

            // Now cut out the ellipse shape to reveal fruit underneath
            ctx.globalCompositeOperation = 'destination-out';
            ctx.translate(fittedEllipse.cx, fittedEllipse.cy);
            ctx.rotate(fittedEllipse.angle);
            ctx.beginPath();
            ctx.ellipse(0, 0, fittedEllipse.rx, fittedEllipse.ry, 0, 0, 2 * Math.PI);
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            ctx.fill();

            // Draw ellipse outline
            ctx.globalCompositeOperation = 'source-over';
            ctx.strokeStyle = '#ff6600';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.restore(); // Remove clip and reset transforms
        }
    }
};

</script>
</body>
</html>
