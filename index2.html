<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ğŸ¥‘ YOLO Dataset Creator - Enhanced</title>
<script src="https://unpkg.com/@supabase/supabase-js@2.38.0/dist/umd/supabase.js"></script>
<script type="module">
    try {
        const { client } = await import("https://cdn.jsdelivr.net/npm/@gradio/client/+esm");
        window.gradioClient = client;
        window.gradioClientLoaded = true;
        console.log('âœ… Gradio Client loaded successfully');
    } catch (error) {
        console.error('âŒ Failed to load Gradio Client:', error);
        window.gradioClientLoaded = false;
        window.gradioClientError = error.message;
    }
</script>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }

body {
font-family: Arial, sans-serif;
background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
min-height: 100vh;
color: white;
padding: 20px;
}

.container { max-width: 900px; margin: 0 auto; }

.header {
text-align: center;
background: rgba(255,255,255,0.1);
padding: 30px;
border-radius: 20px;
margin-bottom: 30px;
}

h1 { font-size: 2em; margin-bottom: 10px; }

.login-section {
background: rgba(255,255,255,0.15);
padding: 25px;
border-radius: 15px;
text-align: center;
margin: 20px 0;
}

.user-input {
padding: 12px 20px;
border: none;
border-radius: 25px;
font-size: 16px;
margin: 10px;
min-width: 200px;
text-align: center;
background: rgba(255,255,255,0.9);
color: #333;
}

.btn {
padding: 12px 25px;
border: none;
border-radius: 25px;
cursor: pointer;
font-weight: bold;
font-size: 16px;
color: white;
margin: 10px;
background: linear-gradient(45deg, #667eea, #764ba2);
transition: transform 0.2s;
}

.btn:hover { transform: translateY(-2px); }

.main-content { display: none; }

.upload-zone {
border: 2px dashed rgba(255,255,255,0.5);
border-radius: 15px;
padding: 40px 20px;
text-align: center;
margin: 20px 0;
cursor: pointer;
transition: all 0.3s;
}

.upload-zone:hover {
border-color: rgba(255,255,255,0.8);
background: rgba(255,255,255,0.05);
}

.categories {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
gap: 15px;
margin: 20px 0;
}

.category-btn {
padding: 15px 10px;
border: none;
border-radius: 15px;
cursor: pointer;
font-weight: bold;
background: rgba(255,255,255,0.2);
color: white;
border: 2px solid transparent;
transition: all 0.3s;
}

.category-btn:hover {
background: rgba(255,255,255,0.3);
transform: translateY(-2px);
}

.category-btn.selected {
background: linear-gradient(45deg, #ff9a9e, #fecfef);
border-color: white;
box-shadow: 0 4px 15px rgba(255,255,255,0.3);
}

.canvas-container { text-align: center; margin: 20px 0; }

#imageCanvas {
border-radius: 15px;
max-width: 100%;
max-height: 60vh;
cursor: crosshair;
box-shadow: 0 8px 32px rgba(0,0,0,0.3);
}

.parameters-section {
background: rgba(255,255,255,0.1);
border-radius: 15px;
padding: 20px;
margin: 20px 0;
}

.param-group {
margin-bottom: 20px;
}

.param-group-header {
font-size: 1.2em;
font-weight: bold;
margin-bottom: 15px;
padding: 10px;
background: rgba(255,255,255,0.15);
border-radius: 10px;
cursor: pointer;
user-select: none;
display: flex;
justify-content: space-between;
align-items: center;
}

.param-group-header:hover {
background: rgba(255,255,255,0.2);
}

.toggle-icon {
font-size: 1.5em;
transition: transform 0.3s;
}

.toggle-icon.collapsed {
transform: rotate(-90deg);
}

.param-group-content {
max-height: 1000px;
overflow: hidden;
transition: max-height 0.3s ease;
}

.param-group-content.collapsed {
max-height: 0;
}

.param-item {
background: rgba(255,255,255,0.08);
padding: 15px;
border-radius: 10px;
margin-bottom: 12px;
}

.param-label {
display: flex;
justify-content: space-between;
margin-bottom: 8px;
font-weight: bold;
}

.param-value {
color: #ffd700;
font-size: 1.1em;
}

.slider-container {
position: relative;
padding: 0 10px;
}

.slider-labels {
display: flex;
justify-content: space-between;
font-size: 0.75em;
color: rgba(255,255,255,0.7);
margin-top: 4px;
}

.slider {
width: 100%;
height: 8px;
border-radius: 5px;
outline: none;
-webkit-appearance: none;
}

.slider.linear {
background: linear-gradient(to right, #ff4444, #ffaa00, #44ff44);
}

.slider.optimal {
background: linear-gradient(to right, #ff4444, #ffaa00 25%, #44ff44 50%, #ffaa00 75%, #ff4444);
}

.slider.reversed {
background: linear-gradient(to right, #44ff44, #ffaa00, #ff4444);
}

.slider::-webkit-slider-thumb {
-webkit-appearance: none;
appearance: none;
width: 20px;
height: 20px;
border-radius: 50%;
background: linear-gradient(45deg, #ffd700, #ffed4e);
cursor: pointer;
box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

.slider::-moz-range-thumb {
width: 20px;
height: 20px;
border-radius: 50%;
background: linear-gradient(45deg, #ffd700, #ffed4e);
cursor: pointer;
border: none;
box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

.controls {
display: flex;
justify-content: center;
gap: 10px;
flex-wrap: wrap;
margin: 20px 0;
}

.btn-success { background: linear-gradient(45deg, #56ab2f, #a8e6cf); }
.btn-danger { background: linear-gradient(45deg, #ff416c, #ff4b2b); }
.btn-primary { background: linear-gradient(45deg, #667eea, #764ba2); }

.hidden { display: none !important; }

.notification {
position: fixed;
top: 20px;
right: 20px;
padding: 15px 25px;
border-radius: 10px;
color: white;
font-weight: bold;
z-index: 1000;
transform: translateX(400px);
transition: all 0.3s ease;
max-width: 300px;
box-shadow: 0 4px 15px rgba(0,0,0,0.3);
}

.notification.show { transform: translateX(0); }
.notification.success { background: linear-gradient(45deg, #56ab2f, #a8e6cf); }
.notification.error { background: linear-gradient(45deg, #ff416c, #ff4b2b); }

.status-bar {
padding: 15px;
border-radius: 10px;
margin: 20px 0;
text-align: center;
font-weight: bold;
}

.status-bar.connected { background: rgba(76, 175, 80, 0.3); }
.status-bar.offline { background: rgba(244, 67, 54, 0.3); }

.instructions {
background: rgba(255,255,255,0.1);
padding: 15px;
border-radius: 10px;
margin: 15px 0;
text-align: center;
}

.loading {
text-align: center;
padding: 20px;
font-size: 1.2em;
}
</style>
</head>
<body>
<div class="container">
<div class="header">
<h1>ğŸ¥‘ YOLO Dataset Creator - Enhanced</h1>
<p>××•×¡×£ ×ª××•× ×•×ª ××©×•×ª×£ ×œ××™××•×Ÿ ××•×“×œ ×–×™×”×•×™ ×¢× ×¤×¨××˜×¨×™× ××ª×§×“××™×</p>
</div>

<div id="statusBar" class="status-bar connected">
<span id="statusText">âœ… ××—×•×‘×¨ ×œ××¡×“ × ×ª×•× ×™× ××©×•×ª×£</span>
</div>

<div id="loginSection" class="login-section">
<h2>ğŸš€ ×‘×•× × ×ª×—×™×œ!</h2>
<p><strong>×”×›× ×¡ ××ª ×”×©× ×©×œ×š ×‘×× ×’×œ×™×ª ×‘×œ×‘×“</strong></p>
<p style="font-size: 0.9em; color: #ffeb3b; margin: 10px 0;">âš ï¸ ×¨×§ ××•×ª×™×•×ª ×× ×’×œ×™×•×ª! ×“×•×’××”: Uri, Dan, Maya, Alex</p>
<input type="text" id="userName" class="user-input" placeholder="Your name in English only" maxlength="15">
<br>
<button onclick="login()" class="btn">×”×ª×—×œ ×œ×ª×¨×•×</button>
</div>

<div id="mainApp" class="main-content">
<div class="login-section">
<p>×©×œ×•× <strong id="currentUser"></strong>! ğŸ‘‹</p>
<button onclick="logout()" class="btn btn-danger">×”×ª× ×ª×§</button>
</div>

<div>
<h3>×”×¢×œ××ª ×ª××•× ×” ×—×“×©×”</h3>

<div class="upload-zone" id="uploadZone">
<h3>ğŸ“· ×”×¢×œ×” ×ª××•× ×”</h3>
<p>×œ×—×¥ ×›××Ÿ, ×’×¨×•×¨ ×ª××•× ×” ××• ×¦×œ× ×—×“×©×”</p>
<input type="file" id="imageInput" accept="image/*" style="display:none">
<input type="file" id="cameraInput" accept="image/*" capture="environment" style="display:none">
</div>

<div style="display: flex; gap: 10px; justify-content: center; margin-top: 10px;">
<button onclick="document.getElementById('imageInput').click()" class="btn" style="background: linear-gradient(45deg, #4CAF50, #45a049);">
ğŸ“ ×‘×—×¨ ×§×•×‘×¥
</button>
<button onclick="document.getElementById('cameraInput').click()" class="btn" style="background: linear-gradient(45deg, #2196F3, #1976D2);">
ğŸ“· ×¦×œ× ×ª××•× ×”
</button>
</div>

<div id="categorySection" class="hidden">
<h3>×‘×—×¨ ××ª ×¡×•×’ ×”××•×¦×¨:</h3>
<div class="categories">
<button class="category-btn" data-category="0" data-product="avocado">ğŸ¥‘ ××‘×•×§×“×•</button>
<button class="category-btn" data-category="1" data-product="mango">ğŸ¥­ ×× ×’×•</button>
<button class="category-btn" data-category="2" data-product="cucumber">ğŸ¥’ ××œ×¤×¤×•×Ÿ</button>
<button class="category-btn" data-category="3" data-product="apple">ğŸ ×ª×¤×•×—</button>
<button class="category-btn" data-category="4" data-product="tomato">ğŸ… ×¢×’×‘× ×™×”</button>
<button class="category-btn" data-category="5" data-product="chicken">ğŸ— ×—×–×” ×¢×•×£</button>
</div>
</div>

<div id="canvasSection" class="hidden">
<div class="canvas-container">
<canvas id="imageCanvas"></canvas>
</div>

<div class="instructions">
<strong>×”×•×¨××•×ª:</strong> ×‘×—×¨ ×§×˜×’×•×¨×™×” ×•××– ×œ×—×¥ ×•×’×¨×•×¨ ×¢×œ ×”×ª××•× ×” ×œ×™×¦×™×¨×ª ×¨×™×‘×•×¢ ×¡×‘×™×‘ ×”××•×¦×¨
</div>

<div id="parametersSection" class="parameters-section hidden">
<div id="loadingParams" class="loading">×˜×•×¢×Ÿ ×¤×¨××˜×¨×™×...</div>

<div id="paramsContent" class="hidden">
<h3 style="text-align: center; margin-bottom: 20px;">âš™ï¸ ×”×’×“×¨ ×¤×¨××˜×¨×™× ×œ××•×¦×¨</h3>

<div class="param-group">
<div class="param-group-header" onclick="toggleGroup('visible')">
<span>ğŸ‘ï¸ ×¤×¨××˜×¨×™× × ×¨××™× ×œ××©×ª××©</span>
<span class="toggle-icon" id="toggle-visible">â–¼</span>
</div>
<div class="param-group-content" id="visibleParams"></div>
</div>

<div class="param-group">
<div class="param-group-header" onclick="toggleGroup('hidden')">
<span>ğŸ”’ ×¤×¨××˜×¨×™× × ×¡×ª×¨×™×/×¨×¦×•×™×™×</span>
<span class="toggle-icon" id="toggle-hidden">â–¼</span>
</div>
<div class="param-group-content" id="hiddenParams"></div>
</div>
</div>
</div>

<div class="controls">
                        <button onclick="saveAnnotation()" class="btn btn-success">ğŸ’¾ ×©××•×¨</button>
                        <button onclick="addCurrentAnnotation()" class="btn btn-warning" id="addAnnotationBtn" style="display:none;">â• ×”×•×¡×£ ×× ×•×˜×¦×™×” ×–×•</button>
                        <button onclick="saveAnnotation()" class="btn btn-success">ğŸ’¾ ×©××•×¨ ×”×›×œ</button>
<button onclick="clearCanvas()" class="btn btn-danger">ğŸ—‘ï¸ × ×§×”</button>
<button onclick="resetUpload()" class="btn btn-primary">ğŸ”„ ×ª××•× ×” ×—×“×©×”</button>
</div>
</div>
</div>
</div>
</div>

<script>
const SUPABASE_URL = 'https://kwoiohzrzmwkxkihkogb.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imt3b2lvaHpyem13a3hraWhrb2diIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY4Mzk2MjIsImV4cCI6MjA3MjQxNTYyMn0.FK1zrvXNc-nmoV28Nr4K12MuwC_zAe5QPcZmwDSbCfw';

const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// HuggingFace Space URL
const HF_SPACE_URL = 'ankoru2025/Green';
const HF_API_TOKEN = 'tZfqDUnRvLJbPwcbzq9CWrbPaLydUx6f';

let PARAMETERS = {};
let currentUser = '';
let currentImage = null;
let selectedCategory = null;
let selectedProduct = null;
let currentParameters = {};
let isDrawing = false;
let annotations = [];
let pendingBox = null;
let mlPredictions = null;  // Store ML predictions
let startX, startY;

const categories = ['avocado', 'mango', 'cucumber', 'apple', 'tomato', 'chicken_breast'];
const categoryNames = ['××‘×•×§×“×•', '×× ×’×•', '××œ×¤×¤×•×Ÿ', '×ª×¤×•×—', '×¢×’×‘× ×™×”', '×—×–×” ×¢×•×£'];

const canvas = document.getElementById('imageCanvas');
const ctx = canvas.getContext('2d');

document.addEventListener('DOMContentLoaded', function() {
initApp();
loadParametersFromSupabase();

// Check Gradio Client availability after short delay (for ES module to load)
setTimeout(() => {
    if (!window.gradioClient) {
        console.warn('âš ï¸ Gradio Client not available - ML predictions disabled');
        const msg = window.gradioClientError
            ? `ML ×œ× ×–××™×Ÿ: ${window.gradioClientError}`
            : 'ML ×œ× ×–××™×Ÿ - ×”×ª×× ×™×“× ×™×ª';
        showNotification(msg, 'error');

        // Alert on mobile
        if (/Mobi|Android|iPhone/i.test(navigator.userAgent)) {
            alert('âš ï¸ ML features not available\n\nPossible reasons:\n- Old browser version\n- Network issues\n- ES modules not supported\n\nYou can still use the app by adjusting sliders manually.');
        }
    } else {
        console.log('âœ… ML ready');
    }
}, 2000);
});

async function loadParametersFromSupabase() {
try {
const { data, error } = await supabase
.from('parameters')
.select('*');

if (error) throw error;

PARAMETERS = {};

data.forEach(row => {
if (!PARAMETERS[row.product]) {
PARAMETERS[row.product] = { visible: {}, hidden: {} };
}

PARAMETERS[row.product][row.param_type][row.param_id] = {
name: row.param_name,
min: row.min_value,
max: row.max_value,
default: row.default_value,
step: row.step_value,
gradient_class: row.gradient_class || 'linear',
left_label: row.left_label || '×’×¨×•×¢',
right_label: row.right_label || '××•×©×œ×'
};
});

console.log('Parameters loaded:', PARAMETERS);
showNotification('âœ… ×¤×¨××˜×¨×™× × ×˜×¢× ×• ×‘×”×¦×œ×—×”', 'success');

} catch (error) {
console.error('Error loading parameters:', error);
showNotification('×©×’×™××” ×‘×˜×¢×™× ×ª ×¤×¨××˜×¨×™×', 'error');
}
}

function initApp() {
const imageInput = document.getElementById('imageInput');
const cameraInput = document.getElementById('cameraInput');
const uploadZone = document.getElementById('uploadZone');

// File input change handlers
imageInput.addEventListener('change', handleImageUpload);
cameraInput.addEventListener('change', handleImageUpload);

// Click to upload
uploadZone.addEventListener('click', () => {
imageInput.click();
});

// Drag and drop handlers
uploadZone.addEventListener('dragover', (e) => {
e.preventDefault();
e.stopPropagation();
uploadZone.style.borderColor = 'rgba(255,255,255,0.8)';
uploadZone.style.background = 'rgba(255,255,255,0.1)';
});

uploadZone.addEventListener('dragleave', (e) => {
e.preventDefault();
e.stopPropagation();
uploadZone.style.borderColor = 'rgba(255,255,255,0.5)';
uploadZone.style.background = 'transparent';
});

uploadZone.addEventListener('drop', (e) => {
e.preventDefault();
e.stopPropagation();
uploadZone.style.borderColor = 'rgba(255,255,255,0.5)';
uploadZone.style.background = 'transparent';

const files = e.dataTransfer.files;
if (files.length > 0) {
const file = files[0];
if (file.type.startsWith('image/')) {
loadImageFile(file);
} else {
showNotification('âŒ ×× × ×”×¢×œ×” ×§×•×‘×¥ ×ª××•× ×”', 'error');
}
}
});

const categoryBtns = document.querySelectorAll('.category-btn');
categoryBtns.forEach(btn => {
btn.addEventListener('click', () => selectCategory(btn));
});

canvas.addEventListener('mousedown', startDrawing);
canvas.addEventListener('mousemove', drawBoundingBox);
canvas.addEventListener('mouseup', endDrawing);

canvas.addEventListener('touchstart', handleTouch);
canvas.addEventListener('touchmove', handleTouch);
canvas.addEventListener('touchend', handleTouch);

checkExistingUser();
}

function handleTouch(e) {
e.preventDefault();
const touch = e.touches[0] || e.changedTouches[0];
const mouseEvent = {
clientX: touch.clientX,
clientY: touch.clientY
};

if (e.type === 'touchstart') startDrawing(mouseEvent);
if (e.type === 'touchmove') drawBoundingBox(mouseEvent);
if (e.type === 'touchend') endDrawing(mouseEvent);
}

function checkExistingUser() {
const savedUser = localStorage.getItem('yolo_user');
if (savedUser) {
currentUser = savedUser;
document.getElementById('currentUser').textContent = currentUser;
showMainApp();
}
}

function login() {
const userName = document.getElementById('userName').value.trim();

if (!userName) {
showNotification('âŒ ×× × ×”×›× ×¡ ×©×', 'error');
return;
}

const englishOnlyRegex = /^[a-zA-Z]+$/;
if (!englishOnlyRegex.test(userName)) {
showNotification('âŒ ×”×©× ×—×™×™×‘ ×œ×”×›×™×œ ×¨×§ ××•×ª×™×•×ª ×× ×’×œ×™×•×ª!', 'error');
return;
}

if (userName.length < 2 || userName.length > 15) {
showNotification('âŒ ×”×©× ×—×™×™×‘ ×œ×”×™×•×ª ×‘×™×Ÿ 2-15 ××•×ª×™×•×ª', 'error');
return;
}

currentUser = userName;
localStorage.setItem('yolo_user', currentUser);
document.getElementById('currentUser').textContent = currentUser;
showNotification('âœ… ×©× ×ª×§×™×Ÿ! ××ª×—×™×œ...', 'success');
showMainApp();
}

function logout() {
localStorage.removeItem('yolo_user');
currentUser = '';
document.getElementById('loginSection').style.display = 'block';
document.getElementById('mainApp').style.display = 'none';
resetUpload();
}

function showMainApp() {
document.getElementById('loginSection').style.display = 'none';
document.getElementById('mainApp').style.display = 'block';
}

function handleImageUpload(e) {
const file = e.target.files[0];
if (file) {
loadImageFile(file);
}
}

function loadImageFile(file) {
if (file.size > 10 * 1024 * 1024) {
showNotification('×§×•×‘×¥ ×’×“×•×œ ××“×™ (××§×¡×™××•× 10MB)', 'error');
return;
}

const reader = new FileReader();
reader.onload = function(e) {
const img = new Image();
img.onload = function() {
currentImage = img;
setupCanvas();
drawImage();
document.getElementById('categorySection').classList.remove('hidden');
document.getElementById('canvasSection').classList.remove('hidden');
annotations = [];
};
img.src = e.target.result;
};
reader.readAsDataURL(file);
}

function setupCanvas() {
const maxWidth = Math.min(600, window.innerWidth - 40);
const maxHeight = 500;

let width = currentImage.width;
let height = currentImage.height;
const aspectRatio = width / height;

if (width > maxWidth) {
width = maxWidth;
height = width / aspectRatio;
}

if (height > maxHeight) {
height = maxHeight;
width = height * aspectRatio;
}

canvas.width = width;
canvas.height = height;
}

function drawImage() {
ctx.clearRect(0, 0, canvas.width, canvas.height);
ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);

            // Draw saved annotations (green) - THIN lines, visual only
annotations.forEach(ann => {
ctx.strokeStyle = '#00ff00';
ctx.lineWidth = 1;  // THIN LINE - visual feedback only, not saved
ctx.strokeRect(ann.x, ann.y, ann.width, ann.height);

ctx.fillStyle = '#00ff00';
ctx.font = 'bold 14px Arial';
ctx.fillText(categoryNames[ann.category], ann.x, ann.y - 5);
});

            // Draw pending box (yellow/orange - waiting for parameters) - THIN
            if (pendingBox) {
                ctx.strokeStyle = '#ffaa00';
                ctx.lineWidth = 2;  // THIN LINE
                ctx.setLineDash([10, 5]);
                ctx.strokeRect(pendingBox.x, pendingBox.y, pendingBox.width, pendingBox.height);
                ctx.setLineDash([]);

                ctx.fillStyle = '#ffaa00';
                ctx.font = 'bold 14px Arial';
                ctx.fillText(categoryNames[pendingBox.category] + ' (×”××ª×Ÿ...)', pendingBox.x, pendingBox.y - 5);
            }
}

function selectCategory(btn) {
document.querySelectorAll('.category-btn').forEach(b => b.classList.remove('selected'));
btn.classList.add('selected');
selectedCategory = parseInt(btn.dataset.category);
selectedProduct = btn.dataset.product;

loadParameters(selectedProduct);
}

function loadParameters(product) {
const params = PARAMETERS[product];
if (!params) {
showNotification('×¤×¨××˜×¨×™× ×¢×“×™×™×Ÿ × ×˜×¢× ×™×...', 'error');
return;
}

currentParameters = {};

document.getElementById('parametersSection').classList.remove('hidden');
document.getElementById('loadingParams').classList.add('hidden');
document.getElementById('paramsContent').classList.remove('hidden');

const visibleContainer = document.getElementById('visibleParams');
const hiddenContainer = document.getElementById('hiddenParams');

visibleContainer.innerHTML = '';
hiddenContainer.innerHTML = '';

Object.entries(params.visible).forEach(([id, paramData]) => {
createParameterSlider(visibleContainer, id, paramData, 'visible');
});

Object.entries(params.hidden).forEach(([id, paramData]) => {
createParameterSlider(hiddenContainer, id, paramData, 'hidden');
});
}

function createParameterSlider(container, id, paramData, type) {
const paramItem = document.createElement('div');
paramItem.className = 'param-item';

const defaultValue = paramData.default;
currentParameters[id] = defaultValue;

const gradientClass = paramData.gradient_class || 'linear';
const leftLabel = paramData.left_label || '×’×¨×•×¢';
const rightLabel = paramData.right_label || '××•×©×œ×';

paramItem.innerHTML = `
               <div class="param-label">
                   <span>${paramData.name}</span>
                   <span class="param-value" id="value-${id}">${defaultValue.toFixed(1)}</span>
               </div>
               <div class="slider-container">
                   <input type="range" class="slider ${gradientClass}" id="slider-${id}"
                          min="${paramData.min}" max="${paramData.max}"
                          step="${paramData.step}" value="${defaultValue}">
                   <div class="slider-labels">
                       <span>${leftLabel}</span>
                       <span>${rightLabel}</span>
                   </div>
               </div>
           `;

container.appendChild(paramItem);

const slider = document.getElementById(`slider-${id}`);
slider.addEventListener('input', function(e) {
const value = parseFloat(e.target.value);
currentParameters[id] = value;
document.getElementById(`value-${id}`).textContent = value.toFixed(1);
});
}

function toggleGroup(groupName) {
const content = document.getElementById(`${groupName}Params`);
const icon = document.getElementById(`toggle-${groupName}`);

content.classList.toggle('collapsed');
icon.classList.toggle('collapsed');
}

function startDrawing(e) {
if (selectedCategory === null) {
showNotification('×‘×—×¨ ×§×˜×’×•×¨×™×” ×ª×—×™×œ×”', 'error');
return;
}

isDrawing = true;
const rect = canvas.getBoundingClientRect();
startX = e.clientX - rect.left;
startY = e.clientY - rect.top;
}

function drawBoundingBox(e) {
if (!isDrawing) return;

const rect = canvas.getBoundingClientRect();
const currentX = e.clientX - rect.left;
const currentY = e.clientY - rect.top;

drawImage();

ctx.strokeStyle = '#ff0000';
ctx.lineWidth = 2;
ctx.strokeRect(startX, startY, currentX - startX, currentY - startY);
}

async function getMLPredictions(x, y, width, height) {
    try {
        showNotification('ğŸ”® ×× ×ª×— ×ª××•× ×”...', 'info');

        // Check if gradioClient is loaded
        if (!window.gradioClient) {
            const reason = window.gradioClientError || 'Unknown';
            throw new Error(`Gradio Client not loaded: ${reason}`);
        }

        // Extract cropped image as blob
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = width;
        tempCanvas.height = height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(canvas, x, y, width, height, 0, 0, width, height);

        const blob = await new Promise(resolve => tempCanvas.toBlob(resolve, 'image/jpeg', 0.9));

        console.log('ğŸ” Connecting to HF Space:', HF_SPACE_URL);

        // Use Gradio Client with timeout
        const app = await Promise.race([
            window.gradioClient(HF_SPACE_URL),
            new Promise((_, reject) => setTimeout(() => reject(new Error('Connection timeout')), 15000))
        ]);

        console.log('ğŸ” Client connected. Checking endpoints...');

        // Try using index 0 (first button/endpoint)
        const result = await Promise.race([
            app.predict(0, [blob, HF_API_TOKEN]),
            new Promise((_, reject) => setTimeout(() => reject(new Error('Prediction timeout')), 20000))
        ]);

        console.log('ğŸ” Result:', result);
        console.log('ğŸ” Result.data[2]:', result.data[2]);

        // The JSON output is already parsed as object
        const predictions = result.data[2];
        console.log('ğŸ” Predictions:', predictions);

        // Store and fill sliders
        mlPredictions = {...predictions.visible_params, ...predictions.hidden_params};

        Object.entries(mlPredictions).forEach(([paramId, value]) => {
            currentParameters[paramId] = value;
            const slider = document.getElementById(`slider-${paramId}`);
            const valueDisplay = document.getElementById(`value-${paramId}`);
            if (slider && valueDisplay) {
                slider.value = value;
                valueDisplay.textContent = value.toFixed(1);
            }
        });

        showNotification('âœ¨ ML ×¦×¤×”! ×ª×§×Ÿ ×× ×¦×¨×™×š', 'success');

    } catch (error) {
        console.error('âŒ ML error:', error);
        mlPredictions = null;

        // More detailed error message
        let errorMsg = 'âš ï¸ ML ×œ× ×–××™×Ÿ';
        if (error.message.includes('gradioClient')) {
            errorMsg += ' (×¡×¤×¨×™×™×” ×œ× × ×˜×¢× ×”)';
        } else if (error.message.includes('timeout')) {
            errorMsg += ' (×–××Ÿ ×—×™×‘×•×¨)';
        } else if (error.message.includes('network')) {
            errorMsg += ' (×‘×¢×™×™×ª ×¨×©×ª)';
        }
        errorMsg += ' - ×”×ª×× ×™×“× ×™×ª';

        showNotification(errorMsg, 'error');

        // Alert on mobile for easier debugging
        if (/Mobi|Android|iPhone/i.test(navigator.userAgent)) {
            setTimeout(() => {
                alert(`ML Error: ${error.message}\n\nPlease adjust sliders manually.`);
            }, 500);
        }
    }
}

function endDrawing(e) {
if (!isDrawing) return;

            // If there's already a pending box, warn user
            if (pendingBox) {
                showNotification('âš ï¸ ×©××•×¨ ××ª ×”×× ×•×˜×¦×™×” ×”× ×•×›×—×™×ª ×œ×¤× ×™ ×¦×™×•×¨ ×—×“×©', 'error');
                isDrawing = false;
                return;
            }

isDrawing = false;
const rect = canvas.getBoundingClientRect();
const endX = e.clientX - rect.left;
const endY = e.clientY - rect.top;

const x = Math.min(startX, endX);
const y = Math.min(startY, endY);
const width = Math.abs(endX - startX);
const height = Math.abs(endY - startY);

if (width > 20 && height > 20) {
                // Store pending box - DON'T save parameters yet!
                pendingBox = {
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    category: selectedCategory,
                    product: selectedProduct
                };

                // Show the "Add Annotation" button
                document.getElementById('addAnnotationBtn').style.display = 'inline-block';

                // Draw the box temporarily
                drawImage();

                // Get ML predictions
                getMLPredictions(x, y, width, height);
}
}

        function addCurrentAnnotation() {
            if (!pendingBox) {
                showNotification('âš ï¸ ×œ× × ××¦××” ×× ×•×˜×¦×™×” ×××ª×™× ×”', 'error');
                return;
            }

            // Check if user corrected ML
            let userCorrected = false;
            let corrections = {};

            if (mlPredictions) {
                for (const [paramId, mlValue] of Object.entries(mlPredictions)) {
                    const userValue = currentParameters[paramId];
                    if (userValue !== undefined && Math.abs(userValue - mlValue) > 0.1) {
                        userCorrected = true;
                        corrections[paramId] = userValue - mlValue;
                    }
                }
            }

            // Save with ML metadata
            annotations.push({
                ...pendingBox,
                parameters: {...currentParameters},
                ml_predictions: mlPredictions ? {...mlPredictions} : null,
                user_corrected: userCorrected,
                corrections: Object.keys(corrections).length > 0 ? corrections : null
            });

            // Clear
            pendingBox = null;
            mlPredictions = null;

            // Hide add button
            document.getElementById('addAnnotationBtn').style.display = 'none';

            // Reset parameters
            loadParameters(selectedProduct);

            drawImage();

            const msg = userCorrected ?
                `âœ… × ×©××¨ ×¢× ×ª×™×§×•× ×™×! ×¡×”"×› ${annotations.length}` :
                `âœ… × ×©××¨! ×¡×”"×› ${annotations.length}`;
            showNotification(msg, 'success');
        }

function clearCanvas() {
annotations = [];
            pendingBox = null;
            mlPredictions = null;
            document.getElementById('addAnnotationBtn').style.display = 'none';
drawImage();
            showNotification('× ×•×§×”', 'success');
}

function resetUpload() {
currentImage = null;
selectedCategory = null;
selectedProduct = null;
currentParameters = {};
annotations = [];
            pendingBox = null;
            mlPredictions = null;
            document.getElementById('addAnnotationBtn').style.display = 'none';
document.getElementById('categorySection').classList.add('hidden');
document.getElementById('canvasSection').classList.add('hidden');
document.getElementById('parametersSection').classList.add('hidden');
document.getElementById('loadingParams').classList.remove('hidden');
document.getElementById('paramsContent').classList.add('hidden');
document.getElementById('imageInput').value = '';
document.querySelectorAll('.category-btn').forEach(b => b.classList.remove('selected'));
}

async function saveAnnotation() {
if (!currentImage || annotations.length === 0) {
showNotification('××™×Ÿ ×× ×•×˜×¦×™×•×ª ×œ×©××•×¨', 'error');
return;
}

try {
showNotification('×©×•××¨...', 'success');

// IMPORTANT: Save ORIGINAL image WITHOUT annotation lines
// Create a temporary canvas with ONLY the original image
const tempCanvas = document.createElement('canvas');
tempCanvas.width = canvas.width;
tempCanvas.height = canvas.height;
const tempCtx = tempCanvas.getContext('2d');
tempCtx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);

const blob = await new Promise(resolve => {
tempCanvas.toBlob(resolve, 'image/jpeg', 0.8);
});

const fileName = `${Date.now()}_${currentUser.toLowerCase()}.jpg`;

const { data: uploadData, error: uploadError } = await supabase.storage
.from('images')
.upload(fileName, blob);

if (uploadError) {
throw new Error(`Upload failed: ${uploadError.message}`);
}

const yoloAnnotations = annotations.map(ann => ({
category: ann.category,
product: ann.product,
center_x: (ann.x + ann.width / 2) / canvas.width,
center_y: (ann.y + ann.height / 2) / canvas.height,
width: ann.width / canvas.width,
height: ann.height / canvas.height,
parameters: ann.parameters
}));

const { data, error } = await supabase
.from('annotations')
.insert([{
user_name: currentUser,
image_path: fileName,
annotations: yoloAnnotations,
created_at: new Date().toISOString()
}]);

if (error) {
throw new Error(`Database save failed: ${error.message}`);
}

showNotification(`âœ… × ×©××¨ ×‘×”×¦×œ×—×”! ${annotations.length} ××•×‘×™×™×§×˜×™×`, 'success');
resetUpload();

} catch (error) {
console.error('Error:', error);
showNotification(`×©×’×™××”: ${error.message}`, 'error');
saveLocally();
}
}

function saveLocally() {
const localData = JSON.parse(localStorage.getItem('yolo_dataset') || '[]');

const yoloAnnotations = annotations.map(ann => ({
category: ann.category,
product: ann.product,
center_x: (ann.x + ann.width / 2) / canvas.width,
center_y: (ann.y + ann.height / 2) / canvas.height,
width: ann.width / canvas.width,
height: ann.height / canvas.height,
parameters: ann.parameters
}));

// Save ORIGINAL image WITHOUT annotation lines
const tempCanvas = document.createElement('canvas');
tempCanvas.width = canvas.width;
tempCanvas.height = canvas.height;
const tempCtx = tempCanvas.getContext('2d');
tempCtx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);

localData.push({
id: Date.now(),
user_name: currentUser,
annotations: yoloAnnotations,
image_data: tempCanvas.toDataURL('image/jpeg', 0.8),
created_at: new Date().toISOString()
});

localStorage.setItem('yolo_dataset', JSON.stringify(localData));
showNotification('ğŸ’¾ × ×©××¨ ××§×•××™×ª ×‘×˜×œ×¤×•×Ÿ', 'success');
resetUpload();
}

function showNotification(message, type) {
const existing = document.querySelector('.notification');
if (existing) existing.remove();

const notification = document.createElement('div');
notification.className = 'notification ' + type;
notification.textContent = message;
document.body.appendChild(notification);

setTimeout(() => notification.classList.add('show'), 100);

setTimeout(() => {
notification.classList.remove('show');
setTimeout(() => notification.remove(), 300);
}, 4000);
}
</script>
</body>
</html>
