<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <title>ü•ë Senseat Grading v7</title>
    <script src="https://unpkg.com/@supabase/supabase-js@2.38.0/dist/umd/supabase.js"></script>
    <script type="module">
        try {
            const { client } = await import("https://cdn.jsdelivr.net/npm/@gradio/client/+esm");
            window.gradioClient = client;
            window.gradioClientLoaded = true;
            console.log('‚úÖ Gradio Client loaded');
        } catch (error) {
            console.error('‚ùå Gradio Client failed:', error);
            window.gradioClientLoaded = false;
        }
    </script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --green: #27ae60;
            --red: #e74c3c;
            --orange: #f39c12;
            --yellow: #ffd700;
            --bg: #f8f9fa;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg);
        }

        /* COMPACT LAYOUT - NO SCROLLING */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: -webkit-fill-available;
            max-height: 100vh;
        }

        /* HEADER - Minimal */
        .header {
            flex: 0 0 auto;
            padding: 8px;
            background: white;
            border-bottom: 2px solid var(--green);
            text-align: center;
        }
        .header h1 {
            font-size: 1.1rem;
            color: var(--green);
            font-weight: 700;
        }

        /* VIDEO SECTION - Flexible */
        .video-section {
            flex: 1 1 auto;
            position: relative;
            background: #000;
            overflow: hidden;
            min-height: 0;
        }

        .viewport-wrapper {
            width: 100%;
            height: 100%;
            position: relative;
        }

        video, canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        video { z-index: 1; }
        canvas { z-index: 10; pointer-events: none; }

        /* ROI GUIDE - RECTANGLE 50% width √ó 50% height - Only shows when camera ready */
        .roi-guide {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50%;
            height: 50%;
            border: 4px dashed var(--yellow);
            border-radius: 12px;
            z-index: 15;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.6);
        }
        .roi-guide.visible {
            opacity: 1;
            animation: roi-pulse 2s infinite;
        }
        .roi-guide::before {
            content: 'üéØ READY TO GRADE';
            position: absolute;
            top: -35px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--yellow);
            color: #000;
            padding: 6px 16px;
            border-radius: 8px;
            font-size: 0.8rem;
            font-weight: bold;
            letter-spacing: 1px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            white-space: nowrap;
        }

        @keyframes roi-pulse {
            0%, 100% {
                box-shadow: 0 0 40px rgba(255, 215, 0, 0.6);
            }
            50% {
                box-shadow: 0 0 60px rgba(255, 215, 0, 0.9);
            }
        }

        /* STATUS BADGE */
        .status-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 20;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.7rem;
            font-weight: bold;
            backdrop-filter: blur(4px);
        }
        .status-badge.ready { background: var(--green); }
        .status-badge.active { background: var(--red); animation: pulse 1.5s infinite; }
        .status-badge.paused { background: var(--orange); }

        /* LOADING OVERLAY */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 30;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            opacity: 1;
            transition: opacity 0.5s;
        }
        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top-color: var(--yellow);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* PAUSE OVERLAY */
        .pause-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 25;
            background: var(--red);
            color: white;
            padding: 20px 30px;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        .pause-overlay.visible { opacity: 1; }

        /* PERFORMANCE OVERLAY */
        .perf-overlay {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 20;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 10px;
            border-radius: 6px;
            font-size: 0.65rem;
            font-family: 'Courier New', monospace;
            line-height: 1.4;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .perf-overlay.visible { opacity: 1; }

        /* BUTTON SECTION - Fixed at bottom, always visible */
        .button-section {
            flex: 0 0 auto;
            padding: 12px;
            background: white;
            border-top: 2px solid #ddd;
            display: flex;
            gap: 8px;
        }

        .senseat-btn {
            flex: 1;
            padding: 16px;
            border: none;
            border-radius: 50px;
            font-size: 1.3rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            background: linear-gradient(135deg, #2d5016, #568203);
            color: white;
            letter-spacing: 1px;
        }
        .senseat-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .senseat-btn.active {
            background: linear-gradient(135deg, var(--red), #c0392b);
            animation: pulse-glow 2s infinite;
        }
        .senseat-btn.paused {
            background: linear-gradient(135deg, var(--orange), #e67e22);
        }
        .senseat-btn.counting {
            box-shadow: inset 0 4px 8px rgba(0,0,0,0.3);
            background: linear-gradient(135deg, #1a3009, #3a5a02);
            transform: scale(0.98);
        }
        .senseat-btn:active:not(:disabled) {
            transform: scale(0.98);
        }

        .tag-btn {
            flex: 0 0 auto;
            padding: 16px 20px;
            border: none;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }
        .tag-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .tag-btn:active:not(:disabled) {
            transform: scale(0.98);
        }

        /* MANUAL TAGGING MODAL */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
            padding: 20px;
        }
        .modal-overlay.visible {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 20px;
            max-width: 900px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }

        .modal-header {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 20px 20px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 1.5rem;
        }

        .close-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            font-size: 1.5rem;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
        }
        .close-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.1);
        }

        .modal-body {
            padding: 20px;
        }

        .segment-navigation {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        .nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        .nav-btn:active:not(:disabled) {
            transform: scale(0.95);
        }

        .segment-info {
            font-size: 1.2rem;
            font-weight: bold;
            color: #2d5016;
        }

        .frozen-image {
            width: 100%;
            max-height: 400px;
            object-fit: contain;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .param-group {
            margin-bottom: 20px;
        }

        .param-group-header {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            padding: 10px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.15), rgba(118, 75, 162, 0.15));
            border-radius: 10px;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #2d5016;
        }

        .param-group-header:hover {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.25), rgba(118, 75, 162, 0.25));
        }

        .toggle-icon {
            font-size: 1.5em;
            transition: transform 0.3s;
        }

        .toggle-icon.collapsed {
            transform: rotate(-90deg);
        }

        .param-group-content {
            max-height: 1000px;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .param-group-content.collapsed {
            max-height: 0;
        }

        .param-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 12px;
        }

        .param-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-weight: bold;
            color: #333;
        }

        .param-value {
            color: #667eea;
            font-size: 1.1em;
        }

        .slider-container {
            position: relative;
            padding: 0 10px;
        }

        .slider-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.75em;
            color: #666;
            margin-top: 4px;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            outline: none;
            -webkit-appearance: none;
        }

        .slider.linear {
            background: linear-gradient(to right, #ff4444, #ffaa00, #44ff44);
        }

        .slider.optimal {
            background: linear-gradient(to right, #ff4444, #ffaa00 25%, #44ff44 50%, #ffaa00 75%, #ff4444);
        }

        .slider.reversed {
            background: linear-gradient(to right, #44ff44, #ffaa00, #ff4444);
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #e0e0e0;
        }

        .action-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .action-btn.save {
            background: linear-gradient(45deg, #56ab2f, #a8e6cf);
            color: white;
        }

        .action-btn.save:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .action-btn.close {
            background: linear-gradient(45deg, #ff416c, #ff4b2b);
            color: white;
        }

        .action-btn:active:not(:disabled) {
            transform: scale(0.95);
        }

        .success-message {
            background: linear-gradient(45deg, #56ab2f, #a8e6cf);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            text-align: center;
            font-weight: bold;
            display: none;
        }

        .success-message.visible {
            display: block;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .segment-preview {
            width: 25%;
            max-width: 200px;
            border: 2px solid #666;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .modal-body-layout {
            display: flex;
            flex-direction: column;
        }

        /* CONTROLS - Compact, collapsible */
        .controls-section {
            flex: 0 0 auto;
            max-height: 30vh;
            overflow-y: auto;
            background: white;
            border-top: 1px solid #ddd;
        }

        .controls-header {
            padding: 10px 12px;
            background: #f8f9fa;
            border-bottom: 1px solid #ddd;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            font-weight: 600;
        }
        .controls-header:active {
            background: #e9ecef;
        }

        .controls-content {
            padding: 12px;
            display: none;
        }
        .controls-content.visible {
            display: block;
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 12px;
        }
        .metric {
            background: #f8f9fa;
            padding: 8px;
            border-radius: 6px;
            text-align: center;
        }
        .metric-label {
            font-size: 0.65rem;
            color: #666;
            text-transform: uppercase;
        }
        .metric-value {
            font-size: 1rem;
            font-weight: 700;
            color: #2d5016;
            margin-top: 2px;
        }
        .metric-value.warning { color: var(--orange); }

        .control-group {
            margin-bottom: 15px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .control-group h3 {
            margin: 0 0 10px 0;
            font-size: 0.85rem;
            font-weight: 600;
            color: #2d5016;
        }

        .slider-row {
            margin-bottom: 10px;
        }
        .slider-row label {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            margin-bottom: 4px;
            font-weight: 600;
        }
        input[type=range] {
            width: 100%;
            accent-color: var(--green);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 4px 12px rgba(231, 76, 60, 0.4); }
            50% { box-shadow: 0 6px 20px rgba(231, 76, 60, 0.7); }
        }

        /* MOBILE OPTIMIZATIONS */
        @media (max-width: 600px) {
            .header h1 { font-size: 1rem; }
            .senseat-btn { font-size: 1.1rem; padding: 14px; }
            .tag-btn { font-size: 0.9rem; padding: 14px 16px; }
            .modal-content { max-width: 100%; }
        }
    </style>
</head>
<body>

<div class="app-container">
    <!-- HEADER -->
    <div class="header">
        <h1>ü•ë Senseat Real-Time Grading v7</h1>
        <input type="text" id="userName" placeholder="Enter your name" style="padding: 4px 8px; margin-top: 5px;">
    </div>

    <!-- VIDEO SECTION -->
    <div class="video-section">
        <div class="viewport-wrapper">
            <video id="video" autoplay playsinline muted webkit-playsinline></video>
            <canvas id="overlay"></canvas>

            <!-- ROI GUIDE - Only visible when ready -->
            <div id="roiGuide" class="roi-guide"></div>

            <!-- STATUS BADGE -->
            <div id="statusBadge" class="status-badge">LOADING...</div>

            <!-- LOADING OVERLAY -->
            <div id="loadingOverlay" class="loading-overlay">
                <div class="loading-spinner"></div>
                <div id="loadingText">Starting Camera...</div>
            </div>

            <!-- PAUSE OVERLAY -->
            <div id="pauseOverlay" class="pause-overlay">
                ‚è∏Ô∏è PAUSED<br><small>Max 4 unique items graded</small>
            </div>

            <!-- PERFORMANCE OVERLAY -->
            <div id="perfOverlay" class="perf-overlay"></div>
        </div>
    </div>

    <!-- BUTTON SECTION - Always visible, no scroll -->
    <div class="button-section">
        <button id="btnSenseat" class="senseat-btn" disabled>‚è≥ STARTING...</button>
        <button id="btnTag" class="tag-btn" disabled>üè∑Ô∏è TAG</button>
    </div>

    <!-- CONTROLS SECTION - Collapsible -->
    <div class="controls-section">
        <div class="controls-header" id="controlsToggle">
            <span>‚öôÔ∏è Settings & Metrics</span>
            <span id="toggleIcon">‚ñº</span>
        </div>
        <div class="controls-content" id="controlsContent">
            <div class="metrics">
                <div class="metric">
                    <div class="metric-label">In ROI</div>
                    <div class="metric-value" id="metricROI">0</div>
                </div>
                <div class="metric">
                    <div class="metric-label">Unique</div>
                    <div class="metric-value" id="metricGraded">0</div>
                </div>
                <div class="metric">
                    <div class="metric-label">Graded</div>
                    <div class="metric-value warning" id="metricCalls">0/4</div>
                </div>
            </div>

            <div class="control-group">
                <h3>üé® Visual Options</h3>
                <div style="display: grid; gap: 8px;">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="chkShowScores" checked onchange="CONFIG.visuals.showScores = this.checked; drawResults();">
                        <span>Show Score Numbers</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="chkShowThumbs" checked onchange="CONFIG.visuals.showThumbsUp = this.checked; drawResults();">
                        <span>Show üëç (Best)</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="chkShowChecks" checked onchange="CONFIG.visuals.showCheckmarks = this.checked; drawResults();">
                        <span>Show ‚úì/‚úó Marks</span>
                    </label>
                    <div style="margin-top: 5px;">
                        <label style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                            <span>Overlay Opacity:</span>
                            <span id="lblOpacity">45%</span>
                        </label>
                        <input type="range" id="inOpacity" min="10" max="80" value="45"
                               oninput="CONFIG.visuals.ellipseOpacity = this.value / 100; document.getElementById('lblOpacity').textContent = this.value + '%'; drawResults();">
                    </div>
                </div>
            </div>

            <div class="slider-row">
                <label>Sample Rate <span id="lblRate">4.0s</span></label>
                <input type="range" id="inRate" min="1" max="10" step="0.5" value="4">
            </div>
            <div class="slider-row">
                <label>Hue <span id="lblHue">105¬∞</span></label>
                <input type="range" id="inHue" min="40" max="160" value="105">
            </div>
            <div class="slider-row">
                <label>Range <span id="lblRange">¬±25¬∞</span></label>
                <input type="range" id="inRange" min="5" max="60" value="25">
            </div>
            <div class="slider-row">
                <label>Min Size <span id="lblMinSize">350px</span></label>
                <input type="range" id="inMinSize" min="100" max="1000" step="50" value="350">
            </div>
        </div>
    </div>
</div>

<!-- MANUAL TAGGING MODAL -->
<div id="modalOverlay" class="modal-overlay">
    <div class="modal-content">
        <div class="modal-header">
            <h2>üè∑Ô∏è Manual Tagging Mode</h2>
            <button class="close-btn" onclick="closeTagModal()">√ó</button>
        </div>
        <div class="modal-body">
            <div class="segment-navigation">
                <button class="nav-btn" id="btnPrevSeg" onclick="navigateSegment(-1)">‚óÄ Previous</button>
                <div class="segment-info" id="segmentInfo">Segment 1 of 1</div>
                <button class="nav-btn" id="btnNextSeg" onclick="navigateSegment(1)">Next ‚ñ∂</button>
            </div>

            <div style="display: flex; gap: 15px; margin-bottom: 20px; align-items: flex-start;">
                <canvas id="segmentPreview" class="segment-preview"></canvas>
                <div style="flex: 1;">
                    <p style="margin: 0; padding: 10px; background: rgba(102, 126, 234, 0.1); border-radius: 8px;">
                        <strong>Segment Preview</strong><br>
                        <small>25% size preview of the selected segment</small>
                    </p>
                </div>
            </div>

            <div class="total-score-display" id="totalScoreDisplay" style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; padding: 15px; border-radius: 10px; text-align: center; margin-bottom: 20px;">
                <div style="font-size: 0.9em; opacity: 0.9; margin-bottom: 5px;">TOTAL SCORE</div>
                <div style="font-size: 2.5em; font-weight: bold;" id="totalScoreValue">7.5</div>
                <div style="font-size: 0.8em; opacity: 0.8; margin-top: 5px;" id="totalScoreCategory">Good Quality</div>
            </div>

            <div id="tagParametersSection">
                <div class="param-group">
                    <div class="param-group-header" onclick="toggleTagGroup('visible')">
                        <span>üëÅÔ∏è Visible Parameters</span>
                        <span class="toggle-icon" id="toggle-tag-visible">‚ñº</span>
                    </div>
                    <div class="param-group-content" id="tagVisibleParams"></div>
                </div>

                <div class="param-group">
                    <div class="param-group-header" onclick="toggleTagGroup('hidden')">
                        <span>üîí Hidden Parameters</span>
                        <span class="toggle-icon" id="toggle-tag-hidden">‚ñº</span>
                    </div>
                    <div class="param-group-content" id="tagHiddenParams"></div>
                </div>
            </div>

            <div class="success-message" id="successMessage">
                ‚úÖ Correction saved successfully!
            </div>

            <div class="modal-actions">
                <button class="action-btn save" id="btnSaveCorrection" onclick="saveCorrection()" disabled>
                    üíæ Save Correction
                </button>
                <button class="action-btn close" onclick="closeTagModal()">
                    Close
                </button>
            </div>
        </div>
    </div>
</div>

<!-- SENSEAT SOUND -->
<audio id="senseatSound" src="sense_it.wav" preload="auto"></audio>

<script>
// ============================================
// SUPABASE CONFIGURATION
// ============================================
const SUPABASE_URL = 'https://kwoiohzrzmwkxkihkogb.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imt3b2lvaHpyem13a3hraWhrb2diIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY4Mzk2MjIsImV4cCI6MjA3MjQxNTYyMn0.FK1zrvXNc-nmoV28Nr4K12MuwC_zAe5QPcZmwDSbCfw';
const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// ============================================
// CONFIGURATION
// ============================================
const CONFIG = {
    scale: 0.35,
    HF_SPACE_URL: 'ankoru2025/Green',
    HF_API_TOKEN: 'tZfqDUnRvLJbPwcbzq9CWrbPaLydUx6f',
    MAX_SAMPLES: 4,  // 4 samples total
    MAX_SEGMENTS_PER_SAMPLE: 5,  // up to 5 segments per sample
    ROI: { widthPercent: 0.5, heightPercent: 0.5 }, // Rectangle ROI: 50% width √ó 50% height
    colors: {
        excellent: 'rgba(39, 174, 96, 0.45)',
        good: 'rgba(52, 152, 219, 0.45)',
        medium: 'rgba(243, 156, 18, 0.45)',
        poor: 'rgba(231, 76, 60, 0.45)',
        pending: 'rgba(149, 165, 166, 0.3)'
    },
    strokes: {
        excellent: '#27ae60',
        good: '#3498db',
        medium: '#f39c12',
        poor: '#e74c3c',
        pending: '#95a5a6'
    },
    visuals: {
        showScores: true,
        showThumbsUp: true,
        showCheckmarks: true,
        ellipseOpacity: 0.45
    }
};

// PARAMETERS DEFINITION (from index2.html structure)
const PARAMETERS = {
    avocado: {
        visible: {
            color: { name: 'Color', min: 1, max: 10, default: 5, step: 0.1, gradient_class: 'linear', left_label: 'Poor', right_label: 'Perfect' },
            texture: { name: 'Texture', min: 1, max: 10, default: 5, step: 0.1, gradient_class: 'linear', left_label: 'Poor', right_label: 'Perfect' },
            firmness: { name: 'Firmness', min: 1, max: 10, default: 5, step: 0.1, gradient_class: 'optimal', left_label: 'Soft', right_label: 'Hard' }
        },
        hidden: {
            freshness: { name: 'Freshness', min: 1, max: 10, default: 5, step: 0.1, gradient_class: 'linear', left_label: 'Old', right_label: 'Fresh' },
            ripeness: { name: 'Ripeness', min: 1, max: 10, default: 5, step: 0.1, gradient_class: 'optimal', left_label: 'Unripe', right_label: 'Overripe' }
        }
    }
};

// ============================================
// STATE
// ============================================
const STATE = {
    cameraReady: false,
    senseatActive: false,
    intervalId: null,
    detected: [],
    detectedInROI: [],
    graded: new Map(),
    gradedHashes: new Set(), // Track graded segments to avoid duplicates
    bestSegment: null,
    apiCallCount: 0,
    sampleCount: 0,  // tracks how many samples sent (0-4)
    isPaused: false,
    countdown: 0,
    totalCountdown: 0,  // total seconds remaining
    countdownInterval: null,
    lastProcessedFrame: null,
    frozenSegments: [],
    currentSegmentIndex: 0,
    originalPredictions: {},
    currentPredictions: {},
    valuesChanged: false,
    manualMode: false,
    selectedSegmentIndex: 0
};

// ============================================
// DOM ELEMENTS
// ============================================
const video = document.getElementById('video');
const canvas = document.getElementById('overlay');
const ctx = canvas.getContext('2d');
const senseatSound = document.getElementById('senseatSound');

const loadingOverlay = document.getElementById('loadingOverlay');
const loadingText = document.getElementById('loadingText');
const roiGuide = document.getElementById('roiGuide');
const statusBadge = document.getElementById('statusBadge');
const pauseOverlay = document.getElementById('pauseOverlay');
const perfOverlay = document.getElementById('perfOverlay');

const btnSenseat = document.getElementById('btnSenseat');
const btnTag = document.getElementById('btnTag');
const controlsToggle = document.getElementById('controlsToggle');
const controlsContent = document.getElementById('controlsContent');
const toggleIcon = document.getElementById('toggleIcon');

const inRate = document.getElementById('inRate');
const inHue = document.getElementById('inHue');
const inRange = document.getElementById('inRange');
const inMinSize = document.getElementById('inMinSize');

const modalOverlay = document.getElementById('modalOverlay');
const frozenCanvas = document.getElementById('frozenCanvas');
const segmentPreview = document.getElementById('segmentPreview');
const btnSaveCorrection = document.getElementById('btnSaveCorrection');
const successMessage = document.getElementById('successMessage');

// ============================================
// HASH FUNCTION FOR TRACKING GRADED SEGMENTS
// ============================================
function getSegmentHash(seg) {
    return `${Math.round(seg.cx)},${Math.round(seg.cy)},${Math.round(seg.area)}`;
}

// ============================================
// CONTROLS TOGGLE
// ============================================
controlsToggle.onclick = () => {
    controlsContent.classList.toggle('visible');
    toggleIcon.textContent = controlsContent.classList.contains('visible') ? '‚ñ≤' : '‚ñº';
};

// ============================================
// CAMERA INITIALIZATION (ROBUST)
// ============================================
window.addEventListener('load', () => {
    console.log('üöÄ Starting camera initialization...');
    setTimeout(initializeCamera, 500);
});

async function initializeCamera() {
    let attempts = 0;
    const maxAttempts = 3;

    while (attempts < maxAttempts && !STATE.cameraReady) {
        attempts++;
        loadingText.textContent = `Starting Camera... (${attempts}/${maxAttempts})`;

        try {
            console.log(`üì∑ Camera attempt ${attempts}/${maxAttempts}`);

            const stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    facingMode: 'environment',
                    width: { ideal: 1280 },
                    height: { ideal: 960 }
                }
            });

            video.srcObject = stream;

            await new Promise((resolve, reject) => {
                video.onloadedmetadata = resolve;
                video.onerror = reject;
                setTimeout(() => reject(new Error('Timeout')), 5000);
            });

            await video.play();

            canvas.width = video.videoWidth || 640;
            canvas.height = video.videoHeight || 480;

            STATE.cameraReady = true;

            loadingOverlay.classList.add('hidden');
            statusBadge.textContent = 'READY';
            statusBadge.classList.add('ready');
            roiGuide.classList.add('visible');
            btnSenseat.disabled = false;
            btnSenseat.textContent = '‚ñ∂ START SENSEAT';
            btnTag.disabled = false;

            console.log('‚úÖ Camera ready!');
            return;

        } catch (error) {
            console.error(`‚ùå Camera attempt ${attempts} failed:`, error);

            if (attempts >= maxAttempts) {
                loadingText.textContent = '‚ùå Camera Failed';
                statusBadge.textContent = 'ERROR';
                statusBadge.style.background = '#e74c3c';
                btnSenseat.textContent = '‚ùå CAMERA ERROR';

                setTimeout(() => {
                    alert(`Camera Error: ${error.message}\n\nPlease:\n1. Allow camera access\n2. Close other apps using camera\n3. Reload the page`);
                }, 1000);

                return;
            }

            await new Promise(resolve => setTimeout(resolve, 1000));
        }
    }
}

// ============================================
// SENSEAT CONTROLS
// ============================================
btnSenseat.onclick = () => {
    if (!STATE.cameraReady) {
        alert('‚ö†Ô∏è Camera not ready. Please wait or reload page.');
        return;
    }

    if (STATE.senseatActive) {
        stopSenseat();
    } else {
        startSenseat();
    }
};

function startSenseat() {
    if (!window.gradioClientLoaded) {
        alert('‚ö†Ô∏è ML model not loaded!\n\nCheck internet and reload page.');
        return;
    }

    STATE.senseatActive = true;
    STATE.isPaused = false;
    STATE.apiCallCount = 0;
    STATE.sampleCount = 0;
    STATE.gradedHashes.clear(); // Reset graded hashes

    // Play senseat sound once
    try {
        senseatSound.currentTime = 0;
        senseatSound.volume = 0.5;
        senseatSound.play()
            .then(() => console.log('‚úÖ Audio played'))
            .catch(err => console.warn('‚ö†Ô∏è Audio failed:', err.message));
    } catch(e) {
        console.error('‚ùå Audio error:', e);
    }

    btnSenseat.textContent = '‚è∏Ô∏è STOP';
    btnSenseat.classList.add('active');
    statusBadge.textContent = 'SENSEAT';
    statusBadge.classList.remove('ready');
    statusBadge.classList.add('active');
    perfOverlay.classList.add('visible');

    // Start countdown once
    startCountdown();

    const rate = parseFloat(inRate.value) * 1000;
    processFrame();
    STATE.intervalId = setInterval(processFrame, rate);

    console.log('‚úÖ Senseat started');
}

function stopSenseat() {
    STATE.senseatActive = false;
    STATE.isPaused = false;

    // Stop countdown if active
    if (STATE.countdownInterval) {
        clearInterval(STATE.countdownInterval);
        STATE.countdownInterval = null;
    }
    STATE.countdown = 0;

    btnSenseat.textContent = '‚ñ∂ START SENSEAT';
    btnSenseat.classList.remove('active', 'paused', 'counting');
    statusBadge.textContent = 'READY';
    statusBadge.classList.remove('active', 'paused');
    statusBadge.classList.add('ready');
    perfOverlay.classList.remove('visible');
    pauseOverlay.classList.remove('visible');

    if (STATE.intervalId) {
        clearInterval(STATE.intervalId);
        STATE.intervalId = null;
    }

    // Reset graded hashes when stopped
    STATE.gradedHashes.clear();

    console.log('‚èπÔ∏è Senseat stopped');
}

function pauseSenseat() {
    STATE.isPaused = true;
    btnSenseat.classList.add('paused');
    btnSenseat.textContent = '‚è∏Ô∏è PAUSED';
    statusBadge.classList.add('paused');
    pauseOverlay.classList.add('visible');
    console.log('‚è∏Ô∏è Auto-paused after 4 samples');
}

function autoFreezeAfterSamples() {
    // Stop Senseat
    stopSenseat();

    // Enable TAG button
    btnTag.disabled = false;

    // Show notification
    console.log('‚úÖ Auto-freeze: 4 samples completed');
}

// ============================================
// COUNTDOWN FEATURE - COUNT FROM TOTAL TO ZERO
// ============================================
function startCountdown() {
    const interval = parseFloat(inRate.value);
    STATE.totalCountdown = Math.floor(CONFIG.MAX_SAMPLES * interval);

    btnSenseat.classList.add('counting');
    updateCountdownDisplay();

    if (STATE.countdownInterval) {
        clearInterval(STATE.countdownInterval);
    }

    STATE.countdownInterval = setInterval(() => {
        STATE.totalCountdown--;
        if (STATE.totalCountdown <= 0) {
            clearInterval(STATE.countdownInterval);
            STATE.countdownInterval = null;
            btnSenseat.classList.remove('counting');
            if (STATE.senseatActive && !STATE.isPaused) {
                btnSenseat.textContent = '‚è∏Ô∏è STOP';
            }
        } else {
            updateCountdownDisplay();
        }
    }, 1000);
}

function updateCountdownDisplay() {
    if (STATE.totalCountdown > 0) {
        btnSenseat.textContent = `Senseat ${STATE.totalCountdown}`;
    } else {
        btnSenseat.textContent = `Senseat 0`;
    }
}

// ============================================
// SLIDER UPDATES
// ============================================
inRate.oninput = () => {
    document.getElementById('lblRate').textContent = inRate.value + 's';
    if (STATE.senseatActive) { stopSenseat(); startSenseat(); }
};
inHue.oninput = () => document.getElementById('lblHue').textContent = inHue.value + '¬∞';
inRange.oninput = () => document.getElementById('lblRange').textContent = '¬±' + inRange.value + '¬∞';
inMinSize.oninput = () => document.getElementById('lblMinSize').textContent = inMinSize.value + 'px';

// ============================================
// PROCESSING PIPELINE
// ============================================
async function processFrame() {
    if (!STATE.cameraReady || video.readyState !== 4 || STATE.isPaused) return;

    const startTime = performance.now();

    const frameCanvas = document.createElement('canvas');
    frameCanvas.width = video.videoWidth;
    frameCanvas.height = video.videoHeight;
    frameCanvas.getContext('2d').drawImage(video, 0, 0);

    // Store last processed frame for manual tagging
    STATE.lastProcessedFrame = frameCanvas;

    const allSegments = segmentFrame(frameCanvas);
    const roiSegments = filterSegmentsInROI(allSegments, frameCanvas.width, frameCanvas.height);

    // Filter out already-graded segments
    const newSegments = roiSegments.filter(seg => !STATE.gradedHashes.has(getSegmentHash(seg)));

    console.log(`üìä Detected: ${allSegments.length} total, ${roiSegments.length} in ROI, ${newSegments.length} new`);

    STATE.detected = allSegments;
    STATE.detectedInROI = roiSegments;

    const segmentTime = performance.now();

    if (newSegments.length > 0) {
        // Limit to max 5 segments per sample
        const segmentsToGrade = newSegments.slice(0, CONFIG.MAX_SEGMENTS_PER_SAMPLE);
        console.log(`üéØ Segments to grade:`, segmentsToGrade.map(s => `#${s.id}`));

        await gradeSegmentsParallel(segmentsToGrade, frameCanvas);

        // Add new segments to graded hashes
        segmentsToGrade.forEach(seg => {
            STATE.gradedHashes.add(getSegmentHash(seg));
        });

        STATE.apiCallCount++;
        STATE.sampleCount++;

        if (STATE.sampleCount >= CONFIG.MAX_SAMPLES) {
            autoFreezeAfterSamples();
        }
    }

    const endTime = performance.now();

    updateMetrics();
    findBestSegment();
    drawResults();

    perfOverlay.innerHTML = `
        Seg: ${(segmentTime - startTime).toFixed(0)}ms<br>
        Grade: ${(endTime - segmentTime).toFixed(0)}ms<br>
        ROI: ${roiSegments.length}/${allSegments.length}<br>
        Samples: ${STATE.sampleCount}/${CONFIG.MAX_SAMPLES}<br>
        Graded: ${STATE.gradedHashes.size}
    `;
}

// ============================================
// ROI FILTER - RECTANGLE 50% width √ó 50% height
// ============================================
function filterSegmentsInROI(segments, frameWidth, frameHeight) {
    const roiWidth = frameWidth * CONFIG.ROI.widthPercent;
    const roiHeight = frameHeight * CONFIG.ROI.heightPercent;
    const roiX = (frameWidth - roiWidth) / 2;
    const roiY = (frameHeight - roiHeight) / 2;

    return segments.filter(seg =>
        seg.cx >= roiX && seg.cx <= roiX + roiWidth &&
        seg.cy >= roiY && seg.cy <= roiY + roiHeight
    );
}

// ============================================
// SEGMENTATION
// ============================================
function segmentFrame(frameCanvas) {
    const fullW = frameCanvas.width;
    const fullH = frameCanvas.height;
    const w = Math.floor(fullW * CONFIG.scale);
    const h = Math.floor(fullH * CONFIG.scale);

    const procCanvas = document.createElement('canvas');
    procCanvas.width = w;
    procCanvas.height = h;
    const procCtx = procCanvas.getContext('2d', { willReadFrequently: true });
    procCtx.drawImage(frameCanvas, 0, 0, w, h);

    const imgData = procCtx.getImageData(0, 0, w, h);
    const pixels = imgData.data;

    const mask = createColorMask(pixels, w, h);
    const cleanMask = morphCleanup(mask, w, h);
    const labels = labelComponents(cleanMask, w, h);
    let blobs = extractBlobs(labels, w, h);
    blobs = filterBlobs(blobs);

    const scale = 1 / CONFIG.scale;
    return blobs.map((b, i) => ({
        id: Date.now() + i,
        cx: b.cx * scale,
        cy: b.cy * scale,
        rx: b.rx * scale,
        ry: b.ry * scale,
        theta: b.theta,
        area: b.area
    }));
}

function createColorMask(pixels, w, h) {
    const mask = new Uint8Array(w * h);
    const targetHue = parseInt(inHue.value);
    const hueTol = parseInt(inRange.value);

    for (let i = 0; i < pixels.length; i += 4) {
        const r = pixels[i] / 255;
        const g = pixels[i + 1] / 255;
        const b = pixels[i + 2] / 255;

        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const lum = (max + min) / 2;

        let hue = 0, sat = 0;

        if (max !== min) {
            const d = max - min;
            sat = lum > 0.5 ? d / (2 - max - min) : d / (max + min);

            switch (max) {
                case r: hue = (g - b) / d + (g < b ? 6 : 0); break;
                case g: hue = (b - r) / d + 2; break;
                case b: hue = (r - g) / d + 4; break;
            }
            hue *= 60;
        }

        const hueDiff = Math.abs(hue - targetHue);
        const hueMatch = hueDiff < hueTol || hueDiff > (360 - hueTol);

        if (hueMatch && sat > 0.10 && sat < 0.75 && lum > 0.06 && lum < 0.50) {
            mask[i / 4] = 1;
        }
    }

    return mask;
}

function morphCleanup(mask, w, h) {
    let result = dilate(mask, w, h, 2);
    result = erode(result, w, h, 2);
    result = erode(result, w, h, 1);
    result = dilate(result, w, h, 1);
    return result;
}

function dilate(mask, w, h, radius) {
    const out = new Uint8Array(w * h);
    for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
            let found = false;
            for (let dy = -radius; dy <= radius && !found; dy++) {
                for (let dx = -radius; dx <= radius && !found; dx++) {
                    const nx = x + dx, ny = y + dy;
                    if (nx >= 0 && nx < w && ny >= 0 && ny < h && mask[ny * w + nx]) found = true;
                }
            }
            out[y * w + x] = found ? 1 : 0;
        }
    }
    return out;
}

function erode(mask, w, h, radius) {
    const out = new Uint8Array(w * h);
    for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
            let allSet = true;
            for (let dy = -radius; dy <= radius && allSet; dy++) {
                for (let dx = -radius; dx <= radius && allSet; dx++) {
                    const nx = x + dx, ny = y + dy;
                    if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                        if (!mask[ny * w + nx]) allSet = false;
                    } else allSet = false;
                }
            }
            out[y * w + x] = allSet ? 1 : 0;
        }
    }
    return out;
}

function labelComponents(mask, w, h) {
    const labels = new Int32Array(w * h);
    let currentLabel = 0;
    for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
            const i = y * w + x;
            if (mask[i] && !labels[i]) {
                currentLabel++;
                floodFill(mask, labels, w, h, x, y, currentLabel);
            }
        }
    }
    return labels;
}

function floodFill(mask, labels, w, h, startX, startY, label) {
    const stack = [[startX, startY]];
    while (stack.length > 0) {
        const [x, y] = stack.pop();
        const i = y * w + x;
        if (x < 0 || x >= w || y < 0 || y >= h || !mask[i] || labels[i]) continue;
        labels[i] = label;
        stack.push([x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]);
    }
}

function extractBlobs(labels, w, h) {
    const blobMap = new Map();
    for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
            const label = labels[y * w + x];
            if (!label) continue;
            if (!blobMap.has(label)) {
                blobMap.set(label, { sumX: 0, sumY: 0, sumXX: 0, sumYY: 0, sumXY: 0, count: 0 });
            }
            const b = blobMap.get(label);
            b.sumX += x; b.sumY += y; b.sumXX += x * x; b.sumYY += y * y; b.sumXY += x * y; b.count++;
        }
    }

    const minBlobArea = parseInt(inMinSize.value);
    const blobs = [];
    for (const [id, b] of blobMap) {
        if (b.count < minBlobArea) continue;
        const cx = b.sumX / b.count;
        const cy = b.sumY / b.count;
        const u20 = (b.sumXX - b.sumX * b.sumX / b.count) / b.count;
        const u02 = (b.sumYY - b.sumY * b.sumY / b.count) / b.count;
        const u11 = (b.sumXY - b.sumX * b.sumY / b.count) / b.count;
        const delta = Math.sqrt(4 * u11 * u11 + (u20 - u02) * (u20 - u02));
        const l1 = (u20 + u02 + delta) / 2;
        const l2 = (u20 + u02 - delta) / 2;
        const rx = 2.0 * Math.sqrt(Math.max(0, l1));
        const ry = 2.0 * Math.sqrt(Math.max(0, l2));
        const theta = 0.5 * Math.atan2(2 * u11, u20 - u02);
        blobs.push({ id, cx, cy, rx, ry, theta, area: b.count });
    }
    return blobs;
}

function filterBlobs(blobs) {
    if (blobs.length === 0) return blobs;
    blobs = blobs.filter(b => {
        const ratio = Math.max(b.rx, b.ry) / Math.max(1, Math.min(b.rx, b.ry));
        return ratio < 3.5;
    });
    if (blobs.length > 1) {
        const maxArea = Math.max(...blobs.map(b => b.area));
        blobs = blobs.filter(b => b.area > maxArea * 0.05);
    }
    return blobs;
}

// ============================================
// GRADING
// ============================================
async function gradeSegmentsParallel(segments, frameCanvas) {
    try {
        const results = await Promise.all(segments.map(seg => gradeSingleSegment(seg, frameCanvas)));
        results.forEach((grade, idx) => STATE.graded.set(segments[idx].id, grade));
    } catch (error) {
        console.error('Grading error:', error);
    }
}

async function gradeSingleSegment(seg, frameCanvas) {
    try {
        console.log(`üîç Grading segment #${seg.id}...`);
        const cropped = cropSegment(seg, frameCanvas);
        const grade = await getMLPrediction(cropped);
        console.log(`‚úÖ Segment #${seg.id}: score=${grade.score?.toFixed(1)}, category=${grade.category}`);
        return grade;
    } catch (error) {
        return { score: NaN, category: 'error', error: error.message };
    }
}

function cropSegment(seg, frameCanvas) {
    const padding = 1.15;
    const bx = Math.max(0, Math.floor(seg.cx - seg.rx * padding));
    const by = Math.max(0, Math.floor(seg.cy - seg.ry * padding));
    const bx2 = Math.min(frameCanvas.width, Math.ceil(seg.cx + seg.rx * padding));
    const by2 = Math.min(frameCanvas.height, Math.ceil(seg.cy + seg.ry * padding));
    const bw = bx2 - bx, bh = by2 - by;

    const cropCanvas = document.createElement('canvas');
    cropCanvas.width = bw;
    cropCanvas.height = bh;
    cropCanvas.getContext('2d').drawImage(frameCanvas, bx, by, bw, bh, 0, 0, bw, bh);
    return cropCanvas;
}

async function getMLPrediction(cropCanvas) {
    try {
        const blob = await new Promise(resolve => cropCanvas.toBlob(resolve, 'image/jpeg', 0.9));
        const app = await window.gradioClient(CONFIG.HF_SPACE_URL);
        const result = await app.predict(0, [blob, CONFIG.HF_API_TOKEN]);
        const predictions = result.data[2];

        if (!predictions?.visible_params || !predictions?.hidden_params) {
            return { score: NaN, category: 'error', error: 'Invalid response' };
        }

        const allParams = { ...predictions.visible_params, ...predictions.hidden_params };
        const values = Object.values(allParams).filter(v => typeof v === 'number' && !isNaN(v));

        if (values.length === 0) return { score: NaN, category: 'error', error: 'No valid params' };

        const avgScore = values.reduce((a, b) => a + b, 0) / values.length;
        if (isNaN(avgScore)) return { score: NaN, category: 'error', error: 'Score NaN' };

        let category = 'medium';
        if (avgScore >= 8) category = 'excellent';
        else if (avgScore >= 6.5) category = 'good';
        else if (avgScore < 4.5) category = 'poor';

        return { score: avgScore, category, params: allParams };
    } catch (error) {
        return { score: NaN, category: 'error', error: error.message };
    }
}

function findBestSegment() {
    let best = null, bestScore = -1;
    STATE.graded.forEach((grade, segId) => {
        if (!isNaN(grade.score) && grade.score > bestScore) {
            bestScore = grade.score;
            best = STATE.detectedInROI.find(s => s.id === segId);
        }
    });
    STATE.bestSegment = best;
}

// ============================================
// DRAWING
// ============================================
function drawResults() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (!STATE.cameraReady) return;

    // Draw outside ROI (gray)
    STATE.detected.forEach(seg => {
        if (!STATE.detectedInROI.some(s => s.id === seg.id)) {
            ctx.beginPath();
            ctx.ellipse(seg.cx, seg.cy, seg.rx * 1.15, seg.ry * 1.15, seg.theta, 0, 2 * Math.PI);
            ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
    });

    // Draw ROI segments
    STATE.detectedInROI.forEach((seg, idx) => {
        const grade = STATE.graded.get(seg.id);
        const category = grade ? grade.category : 'pending';
        const isBest = STATE.bestSegment?.id === seg.id;
        const isSelected = STATE.manualMode && idx === STATE.selectedSegmentIndex;

        ctx.beginPath();
        ctx.ellipse(seg.cx, seg.cy, seg.rx * 1.15, seg.ry * 1.15, seg.theta, 0, 2 * Math.PI);

        // Use opacity setting
        const baseColor = CONFIG.colors[category];
        ctx.fillStyle = baseColor.replace('0.45', CONFIG.visuals.ellipseOpacity);
        ctx.fill();

        // Red border for selected segment in manual mode
        if (isSelected) {
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 6;
        } else {
            ctx.lineWidth = isBest ? 5 : 3;
            ctx.strokeStyle = CONFIG.strokes[category];
        }

        if (isBest && !isSelected) {
            ctx.shadowBlur = 15;
            ctx.shadowColor = CONFIG.strokes[category];
        }
        ctx.stroke();
        ctx.shadowBlur = 0;

        // Only draw score badge if enabled
        if (CONFIG.visuals.showScores && grade && !isNaN(grade.score)) {
            ctx.fillStyle = CONFIG.strokes[category];
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.roundRect(seg.cx - 32, seg.cy - 14, 64, 28, 14);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'white';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(grade.score.toFixed(1), seg.cx, seg.cy);
        }

        // Only draw thumbs up if enabled
        if (CONFIG.visuals.showThumbsUp && isBest && grade && !isNaN(grade.score)) {
            ctx.font = 'bold 48px Arial';
            ctx.shadowBlur = 12;
            ctx.fillText('üëç', seg.cx, seg.cy - seg.ry * 0.7);
            ctx.shadowBlur = 0;
        }

        // Add checkmark/X for quality
        if (CONFIG.visuals.showCheckmarks && grade && !isNaN(grade.score)) {
            const symbol = grade.score >= 6.5 ? '‚úì' : '‚úó';
            const symbolColor = grade.score >= 6.5 ? '#27ae60' : '#e74c3c';
            ctx.font = 'bold 24px Arial';
            ctx.fillStyle = symbolColor;
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.strokeText(symbol, seg.cx + seg.rx * 0.6, seg.cy - seg.ry * 0.6);
            ctx.fillText(symbol, seg.cx + seg.rx * 0.6, seg.cy - seg.ry * 0.6);
        }

        if (grade && isNaN(grade.score)) {
            ctx.fillStyle = '#e74c3c';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('‚ùå', seg.cx, seg.cy);
        }
    });
}

function updateMetrics() {
    document.getElementById('metricROI').textContent = STATE.detectedInROI.length;
    document.getElementById('metricGraded').textContent = STATE.gradedHashes.size;
    document.getElementById('metricCalls').textContent = `${STATE.sampleCount}/4`;
}

// ============================================
// MANUAL TAGGING MODE
// ============================================
btnTag.onclick = () => {
    if (!STATE.lastProcessedFrame || STATE.detectedInROI.length === 0) {
        alert('‚ö†Ô∏è No segments detected. Run Senseat first.');
        return;
    }

    // Stop Senseat if running
    if (STATE.senseatActive) {
        stopSenseat();
    }

    openTagModal();
};

function openTagModal() {
    // Prepare frozen segments with their crops and grades
    STATE.frozenSegments = STATE.detectedInROI.map(seg => {
        const grade = STATE.graded.get(seg.id);
        const cropCanvas = cropSegment(seg, STATE.lastProcessedFrame);
        return {
            segment: seg,
            grade: grade,
            cropCanvas: cropCanvas
        };
    });

    STATE.currentSegmentIndex = 0;
    STATE.selectedSegmentIndex = 0;
    STATE.valuesChanged = false;
    STATE.manualMode = true;

    loadSegmentInModal(0);
    modalOverlay.classList.add('visible');
    drawResults(); // Redraw to show red border
}

function closeTagModal() {
    modalOverlay.classList.remove('visible');
    STATE.frozenSegments = [];
    STATE.currentSegmentIndex = 0;
    STATE.selectedSegmentIndex = 0;
    STATE.originalPredictions = {};
    STATE.currentPredictions = {};
    STATE.valuesChanged = false;
    STATE.manualMode = false;
    successMessage.classList.remove('visible');
    drawResults(); // Redraw to remove red border
}

function loadSegmentInModal(index) {
    if (index < 0 || index >= STATE.frozenSegments.length) return;

    STATE.currentSegmentIndex = index;
    STATE.selectedSegmentIndex = index;
    const frozen = STATE.frozenSegments[index];

    // Update navigation
    document.getElementById('segmentInfo').textContent =
        `Segment ${index + 1} of ${STATE.frozenSegments.length}`;
    document.getElementById('btnPrevSeg').disabled = (index === 0);
    document.getElementById('btnNextSeg').disabled = (index === STATE.frozenSegments.length - 1);

    // Draw segment preview (25% size)
    const previewScale = 0.25;
    const previewWidth = Math.min(200, frozen.cropCanvas.width * previewScale);
    const previewHeight = frozen.cropCanvas.height * (previewWidth / frozen.cropCanvas.width);

    segmentPreview.width = previewWidth;
    segmentPreview.height = previewHeight;
    const prevCtx = segmentPreview.getContext('2d');
    prevCtx.drawImage(frozen.cropCanvas, 0, 0, previewWidth, previewHeight);

    // Draw outline on preview
    prevCtx.strokeStyle = '#667eea';
    prevCtx.lineWidth = 2;
    prevCtx.strokeRect(0, 0, previewWidth, previewHeight);

    // Load parameters
    const params = frozen.grade?.params || {};

    // Initialize with ALL parameter keys (visible + hidden), using defaults if not in ML predictions
    const productParams = PARAMETERS.avocado;
    STATE.originalPredictions = {};
    STATE.currentPredictions = {};

    Object.entries(productParams.visible).forEach(([id, paramData]) => {
        const value = params[id] !== undefined ? params[id] : paramData.default;
        STATE.originalPredictions[id] = value;
        STATE.currentPredictions[id] = value;
    });

    Object.entries(productParams.hidden).forEach(([id, paramData]) => {
        const value = params[id] !== undefined ? params[id] : paramData.default;
        STATE.originalPredictions[id] = value;
        STATE.currentPredictions[id] = value;
    });

    STATE.valuesChanged = false;
    btnSaveCorrection.disabled = true;
    successMessage.classList.remove('visible');

    // Render parameter sliders
    renderTagParameters(params);

    // Calculate and display total score
    const allValues = Object.values(STATE.currentPredictions).filter(v => !isNaN(v));
    const totalScore = allValues.reduce((a, b) => a + b, 0) / allValues.length;

    // Update total score display
    document.getElementById('totalScoreValue').textContent = totalScore.toFixed(1);

    let categoryText = 'Medium Quality';
    if (totalScore >= 8) categoryText = 'üåü Excellent Quality';
    else if (totalScore >= 6.5) categoryText = '‚úÖ Good Quality';
    else if (totalScore < 4.5) categoryText = '‚ö†Ô∏è Poor Quality';
    document.getElementById('totalScoreCategory').textContent = categoryText;

    // Update red border in main view
    drawResults();
}

function renderTagParameters(params) {
    const visibleContainer = document.getElementById('tagVisibleParams');
    const hiddenContainer = document.getElementById('tagHiddenParams');

    visibleContainer.innerHTML = '';
    hiddenContainer.innerHTML = '';

    // Use PARAMETERS structure
    const productParams = PARAMETERS.avocado; // Default to avocado for now

    Object.entries(productParams.visible).forEach(([id, paramData]) => {
        const value = params[id] !== undefined ? params[id] : paramData.default;
        createTagSlider(visibleContainer, id, paramData, value);
    });

    Object.entries(productParams.hidden).forEach(([id, paramData]) => {
        const value = params[id] !== undefined ? params[id] : paramData.default;
        createTagSlider(hiddenContainer, id, paramData, value);
    });
}

function createTagSlider(container, id, paramData, initialValue) {
    const paramItem = document.createElement('div');
    paramItem.className = 'param-item';

    const gradientClass = paramData.gradient_class || 'linear';
    const leftLabel = paramData.left_label || 'Poor';
    const rightLabel = paramData.right_label || 'Perfect';

    paramItem.innerHTML = `
        <div class="param-label">
            <span>${paramData.name}</span>
            <span class="param-value" id="tag-value-${id}">${initialValue.toFixed(1)}</span>
        </div>
        <div class="slider-container">
            <input type="range" class="slider ${gradientClass}" id="tag-slider-${id}"
                   min="${paramData.min}" max="${paramData.max}"
                   step="${paramData.step}" value="${initialValue}">
            <div class="slider-labels">
                <span>${leftLabel}</span>
                <span>${rightLabel}</span>
            </div>
        </div>
    `;

    container.appendChild(paramItem);

    const slider = document.getElementById(`tag-slider-${id}`);
    slider.addEventListener('input', function(e) {
        const value = parseFloat(e.target.value);
        STATE.currentPredictions[id] = value;
        document.getElementById(`tag-value-${id}`).textContent = value.toFixed(1);

        // Check if values changed
        checkIfValuesChanged();
    });
}

function checkIfValuesChanged() {
    STATE.valuesChanged = false;
    for (const key in STATE.currentPredictions) {
        const current = STATE.currentPredictions[key];
        const original = STATE.originalPredictions[key];
        const diff = Math.abs(current - original);

        if (diff > 0.01) {
            STATE.valuesChanged = true;
            console.log(`üîÑ Parameter changed: ${key} (${original.toFixed(1)} ‚Üí ${current.toFixed(1)})`);
            break;
        }
    }
    btnSaveCorrection.disabled = !STATE.valuesChanged;
    console.log(`üíæ Save button ${STATE.valuesChanged ? 'ENABLED' : 'DISABLED'}`);

    // Update total score display
    const allValues = Object.values(STATE.currentPredictions).filter(v => !isNaN(v));
    const totalScore = allValues.reduce((a, b) => a + b, 0) / allValues.length;
    document.getElementById('totalScoreValue').textContent = totalScore.toFixed(1);

    let categoryText = 'Medium Quality';
    if (totalScore >= 8) categoryText = 'üåü Excellent Quality';
    else if (totalScore >= 6.5) categoryText = '‚úÖ Good Quality';
    else if (totalScore < 4.5) categoryText = '‚ö†Ô∏è Poor Quality';
    document.getElementById('totalScoreCategory').textContent = categoryText;
}

function navigateSegment(direction) {
    const newIndex = STATE.currentSegmentIndex + direction;
    if (newIndex >= 0 && newIndex < STATE.frozenSegments.length) {
        loadSegmentInModal(newIndex);
    }
}

function toggleTagGroup(groupName) {
    const content = document.getElementById(`tag${groupName.charAt(0).toUpperCase() + groupName.slice(1)}Params`);
    const icon = document.getElementById(`toggle-tag-${groupName}`);

    content.classList.toggle('collapsed');
    icon.classList.toggle('collapsed');
}

async function saveCorrection() {
    if (!STATE.valuesChanged) return;

    const userName = document.getElementById('userName').value.trim();
    if (!userName) {
        alert('‚ö†Ô∏è Please enter your name first!');
        return;
    }

    const frozen = STATE.frozenSegments[STATE.currentSegmentIndex];
    if (!frozen) return;

    try {
        console.log('üíæ Starting save...');

        // Get segment crop as blob
        const blob = await new Promise((resolve, reject) => {
            frozen.cropCanvas.toBlob(blob => {
                if (blob) resolve(blob);
                else reject(new Error('Failed to create blob'));
            }, 'image/jpeg', 0.85);
        });

        console.log('üì¶ Blob created:', blob.size, 'bytes');

        // Upload to Supabase Storage
        const fileName = `${Date.now()}_${userName.toLowerCase()}_segment.jpg`;
        console.log('üì§ Uploading to Supabase:', fileName);

        const { data: uploadData, error: uploadError } = await supabase.storage
            .from('images')
            .upload(fileName, blob, { contentType: 'image/jpeg' });

        if (uploadError) {
            console.error('‚ùå Upload error:', uploadError);
            throw new Error(`Upload failed: ${uploadError.message}`);
        }

        console.log('‚úÖ Upload success:', uploadData);

        // Calculate total score
        const allValues = Object.values(STATE.currentPredictions).filter(v => !isNaN(v));
        const totalScore = allValues.reduce((a, b) => a + b, 0) / allValues.length;

        // Prepare annotation
        const annotationData = {
            user_name: userName,
            image_path: fileName,
            total_score: totalScore,
            annotations: [{
                segment_id: frozen.segment.id,
                position: { cx: frozen.segment.cx, cy: frozen.segment.cy },
                area: frozen.segment.area,
                parameters: STATE.currentPredictions,
                original_predictions: STATE.originalPredictions
            }],
            created_at: new Date().toISOString()
        };

        console.log('üìù Saving annotation:', annotationData);

        // Save to Supabase
        const { data, error } = await supabase
            .from('annotations')
            .insert([annotationData]);

        if (error) {
            console.error('‚ùå Database error:', error);
            throw new Error(`Database save failed: ${error.message}`);
        }

        console.log('‚úÖ Save success!', data);

        // Show success
        successMessage.classList.add('visible');
        btnSaveCorrection.disabled = true;
        STATE.valuesChanged = false;

        setTimeout(() => successMessage.classList.remove('visible'), 3000);

    } catch (error) {
        console.error('‚ùå Save failed:', error);
        alert(`Failed to save: ${error.message}\n\nPlease check:\n- Internet connection\n- Supabase credentials\n- Storage bucket exists\n- Table exists`);
    }
}

// Polyfill
if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
        this.moveTo(x + r, y);
        this.lineTo(x + w - r, y);
        this.quadraticCurveTo(x + w, y, x + w, y + r);
        this.lineTo(x + w, y + h - r);
        this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        this.lineTo(x + r, y + h);
        this.quadraticCurveTo(x, y + h, x, y + h - r);
        this.lineTo(x, y + r);
        this.quadraticCurveTo(x, y, x + r, y);
        this.closePath();
    };
}

console.log('ü•ë Senseat v7 initialized');
</script>
</body>
</html>
